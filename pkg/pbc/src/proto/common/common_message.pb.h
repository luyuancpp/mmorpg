// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/common_message.proto
// Protobuf C++ Version: 5.26.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2fcommon_5fmessage_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_common_2fcommon_5fmessage_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 5026001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "common/common.pb.h"
#include "common/session.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_common_2fcommon_5fmessage_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2fcommon_5fmessage_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_common_2fcommon_5fmessage_2eproto;
class GateSessionDisconnectRequest;
struct GateSessionDisconnectRequestDefaultTypeInternal;
extern GateSessionDisconnectRequestDefaultTypeInternal _GateSessionDisconnectRequest_default_instance_;
class MessageBody;
struct MessageBodyDefaultTypeInternal;
extern MessageBodyDefaultTypeInternal _MessageBody_default_instance_;
class NodeMessageHead;
struct NodeMessageHeadDefaultTypeInternal;
extern NodeMessageHeadDefaultTypeInternal _NodeMessageHead_default_instance_;
class NodeRouteMessageBody;
struct NodeRouteMessageBodyDefaultTypeInternal;
extern NodeRouteMessageBodyDefaultTypeInternal _NodeRouteMessageBody_default_instance_;
class NodeRouteMessageRequest;
struct NodeRouteMessageRequestDefaultTypeInternal;
extern NodeRouteMessageRequestDefaultTypeInternal _NodeRouteMessageRequest_default_instance_;
class NodeRouteMessageResponse;
struct NodeRouteMessageResponseDefaultTypeInternal;
extern NodeRouteMessageResponseDefaultTypeInternal _NodeRouteMessageResponse_default_instance_;
class PlayerMessageExtern;
struct PlayerMessageExternDefaultTypeInternal;
extern PlayerMessageExternDefaultTypeInternal _PlayerMessageExtern_default_instance_;
class PlayerMessageResponse;
struct PlayerMessageResponseDefaultTypeInternal;
extern PlayerMessageResponseDefaultTypeInternal _PlayerMessageResponse_default_instance_;
class PlayerNodeServiceRequest;
struct PlayerNodeServiceRequestDefaultTypeInternal;
extern PlayerNodeServiceRequestDefaultTypeInternal _PlayerNodeServiceRequest_default_instance_;
class RegisterCentreSessionNodeRequest;
struct RegisterCentreSessionNodeRequestDefaultTypeInternal;
extern RegisterCentreSessionNodeRequestDefaultTypeInternal _RegisterCentreSessionNodeRequest_default_instance_;
class RegisterGameNodeRequest;
struct RegisterGameNodeRequestDefaultTypeInternal;
extern RegisterGameNodeRequestDefaultTypeInternal _RegisterGameNodeRequest_default_instance_;
class RegisterGameNodeSessionRequest;
struct RegisterGameNodeSessionRequestDefaultTypeInternal;
extern RegisterGameNodeSessionRequestDefaultTypeInternal _RegisterGameNodeSessionRequest_default_instance_;
class RegisterGameNodeSessionResponse;
struct RegisterGameNodeSessionResponseDefaultTypeInternal;
extern RegisterGameNodeSessionResponseDefaultTypeInternal _RegisterGameNodeSessionResponse_default_instance_;
class RegisterGateNodeRequest;
struct RegisterGateNodeRequestDefaultTypeInternal;
extern RegisterGateNodeRequestDefaultTypeInternal _RegisterGateNodeRequest_default_instance_;
class RegisterSessionCentreNodeResponse;
struct RegisterSessionCentreNodeResponseDefaultTypeInternal;
extern RegisterSessionCentreNodeResponseDefaultTypeInternal _RegisterSessionCentreNodeResponse_default_instance_;
class RegisterSessionGateNodeResponse;
struct RegisterSessionGateNodeResponseDefaultTypeInternal;
extern RegisterSessionGateNodeResponseDefaultTypeInternal _RegisterSessionGateNodeResponse_default_instance_;
class RouteMsgStringRequest;
struct RouteMsgStringRequestDefaultTypeInternal;
extern RouteMsgStringRequestDefaultTypeInternal _RouteMsgStringRequest_default_instance_;
class RouteMsgStringResponse;
struct RouteMsgStringResponseDefaultTypeInternal;
extern RouteMsgStringResponseDefaultTypeInternal _RouteMsgStringResponse_default_instance_;
class RouteNodeInfo;
struct RouteNodeInfoDefaultTypeInternal;
extern RouteNodeInfoDefaultTypeInternal _RouteNodeInfo_default_instance_;
class RoutePlayerMsgStringRequest;
struct RoutePlayerMsgStringRequestDefaultTypeInternal;
extern RoutePlayerMsgStringRequestDefaultTypeInternal _RoutePlayerMsgStringRequest_default_instance_;
class RoutePlayerMsgStringResponse;
struct RoutePlayerMsgStringResponseDefaultTypeInternal;
extern RoutePlayerMsgStringResponseDefaultTypeInternal _RoutePlayerMsgStringResponse_default_instance_;
class UnRegisterGameNodeRequest;
struct UnRegisterGameNodeRequestDefaultTypeInternal;
extern UnRegisterGameNodeRequestDefaultTypeInternal _UnRegisterGameNodeRequest_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google


// ===================================================================


// -------------------------------------------------------------------

class UnRegisterGameNodeRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:UnRegisterGameNodeRequest) */ {
 public:
  inline UnRegisterGameNodeRequest() : UnRegisterGameNodeRequest(nullptr) {}
  ~UnRegisterGameNodeRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UnRegisterGameNodeRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline UnRegisterGameNodeRequest(const UnRegisterGameNodeRequest& from) : UnRegisterGameNodeRequest(nullptr, from) {}
  inline UnRegisterGameNodeRequest(UnRegisterGameNodeRequest&& from) noexcept
      : UnRegisterGameNodeRequest(nullptr, std::move(from)) {}
  inline UnRegisterGameNodeRequest& operator=(const UnRegisterGameNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnRegisterGameNodeRequest& operator=(UnRegisterGameNodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnRegisterGameNodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnRegisterGameNodeRequest* internal_default_instance() {
    return reinterpret_cast<const UnRegisterGameNodeRequest*>(
        &_UnRegisterGameNodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(UnRegisterGameNodeRequest& a, UnRegisterGameNodeRequest& b) { a.Swap(&b); }
  inline void Swap(UnRegisterGameNodeRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnRegisterGameNodeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnRegisterGameNodeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UnRegisterGameNodeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UnRegisterGameNodeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UnRegisterGameNodeRequest& from) { UnRegisterGameNodeRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UnRegisterGameNodeRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "UnRegisterGameNodeRequest"; }

 protected:
  explicit UnRegisterGameNodeRequest(::google::protobuf::Arena* arena);
  UnRegisterGameNodeRequest(::google::protobuf::Arena* arena, const UnRegisterGameNodeRequest& from);
  UnRegisterGameNodeRequest(::google::protobuf::Arena* arena, UnRegisterGameNodeRequest&& from) noexcept
      : UnRegisterGameNodeRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGameNodeIdFieldNumber = 1,
  };
  // uint32 game_node_id = 1;
  void clear_game_node_id() ;
  ::uint32_t game_node_id() const;
  void set_game_node_id(::uint32_t value);

  private:
  ::uint32_t _internal_game_node_id() const;
  void _internal_set_game_node_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:UnRegisterGameNodeRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t game_node_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class PlayerMessageExtern final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PlayerMessageExtern) */ {
 public:
  inline PlayerMessageExtern() : PlayerMessageExtern(nullptr) {}
  ~PlayerMessageExtern() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerMessageExtern(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerMessageExtern(const PlayerMessageExtern& from) : PlayerMessageExtern(nullptr, from) {}
  inline PlayerMessageExtern(PlayerMessageExtern&& from) noexcept
      : PlayerMessageExtern(nullptr, std::move(from)) {}
  inline PlayerMessageExtern& operator=(const PlayerMessageExtern& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerMessageExtern& operator=(PlayerMessageExtern&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerMessageExtern& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerMessageExtern* internal_default_instance() {
    return reinterpret_cast<const PlayerMessageExtern*>(
        &_PlayerMessageExtern_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(PlayerMessageExtern& a, PlayerMessageExtern& b) { a.Swap(&b); }
  inline void Swap(PlayerMessageExtern* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerMessageExtern* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerMessageExtern* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlayerMessageExtern>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerMessageExtern& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerMessageExtern& from) { PlayerMessageExtern::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerMessageExtern* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PlayerMessageExtern"; }

 protected:
  explicit PlayerMessageExtern(::google::protobuf::Arena* arena);
  PlayerMessageExtern(::google::protobuf::Arena* arena, const PlayerMessageExtern& from);
  PlayerMessageExtern(::google::protobuf::Arena* arena, PlayerMessageExtern&& from) noexcept
      : PlayerMessageExtern(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // uint64 player_id = 1;
  void clear_player_id() ;
  ::uint64_t player_id() const;
  void set_player_id(::uint64_t value);

  private:
  ::uint64_t _internal_player_id() const;
  void _internal_set_player_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:PlayerMessageExtern)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t player_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class NodeMessageHead final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NodeMessageHead) */ {
 public:
  inline NodeMessageHead() : NodeMessageHead(nullptr) {}
  ~NodeMessageHead() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeMessageHead(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeMessageHead(const NodeMessageHead& from) : NodeMessageHead(nullptr, from) {}
  inline NodeMessageHead(NodeMessageHead&& from) noexcept
      : NodeMessageHead(nullptr, std::move(from)) {}
  inline NodeMessageHead& operator=(const NodeMessageHead& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeMessageHead& operator=(NodeMessageHead&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeMessageHead& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeMessageHead* internal_default_instance() {
    return reinterpret_cast<const NodeMessageHead*>(
        &_NodeMessageHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(NodeMessageHead& a, NodeMessageHead& b) { a.Swap(&b); }
  inline void Swap(NodeMessageHead* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeMessageHead* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeMessageHead* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NodeMessageHead>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeMessageHead& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeMessageHead& from) { NodeMessageHead::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeMessageHead* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "NodeMessageHead"; }

 protected:
  explicit NodeMessageHead(::google::protobuf::Arena* arena);
  NodeMessageHead(::google::protobuf::Arena* arena, const NodeMessageHead& from);
  NodeMessageHead(::google::protobuf::Arena* arena, NodeMessageHead&& from) noexcept
      : NodeMessageHead(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionIdFieldNumber = 2,
    kNodeIdFieldNumber = 1,
  };
  // uint64 session_id = 2;
  void clear_session_id() ;
  ::uint64_t session_id() const;
  void set_session_id(::uint64_t value);

  private:
  ::uint64_t _internal_session_id() const;
  void _internal_set_session_id(::uint64_t value);

  public:
  // uint32 node_id = 1;
  void clear_node_id() ;
  ::uint32_t node_id() const;
  void set_node_id(::uint32_t value);

  private:
  ::uint32_t _internal_node_id() const;
  void _internal_set_node_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NodeMessageHead)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t session_id_;
    ::uint32_t node_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class MessageBody final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MessageBody) */ {
 public:
  inline MessageBody() : MessageBody(nullptr) {}
  ~MessageBody() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MessageBody(
      ::google::protobuf::internal::ConstantInitialized);

  inline MessageBody(const MessageBody& from) : MessageBody(nullptr, from) {}
  inline MessageBody(MessageBody&& from) noexcept
      : MessageBody(nullptr, std::move(from)) {}
  inline MessageBody& operator=(const MessageBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageBody& operator=(MessageBody&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageBody& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageBody* internal_default_instance() {
    return reinterpret_cast<const MessageBody*>(
        &_MessageBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(MessageBody& a, MessageBody& b) { a.Swap(&b); }
  inline void Swap(MessageBody* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageBody* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageBody* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<MessageBody>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MessageBody& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MessageBody& from) { MessageBody::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MessageBody* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "MessageBody"; }

 protected:
  explicit MessageBody(::google::protobuf::Arena* arena);
  MessageBody(::google::protobuf::Arena* arena, const MessageBody& from);
  MessageBody(::google::protobuf::Arena* arena, MessageBody&& from) noexcept
      : MessageBody(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBodyFieldNumber = 1,
    kIdFieldNumber = 3,
    kMessageIdFieldNumber = 2,
  };
  // bytes body = 1;
  void clear_body() ;
  const std::string& body() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_body(Arg_&& arg, Args_... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* value);

  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(
      const std::string& value);
  std::string* _internal_mutable_body();

  public:
  // uint64 id = 3;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // uint32 message_id = 2;
  void clear_message_id() ;
  ::uint32_t message_id() const;
  void set_message_id(::uint32_t value);

  private:
  ::uint32_t _internal_message_id() const;
  void _internal_set_message_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MessageBody)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr body_;
    ::uint64_t id_;
    ::uint32_t message_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RoutePlayerMsgStringResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RoutePlayerMsgStringResponse) */ {
 public:
  inline RoutePlayerMsgStringResponse() : RoutePlayerMsgStringResponse(nullptr) {}
  ~RoutePlayerMsgStringResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoutePlayerMsgStringResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RoutePlayerMsgStringResponse(const RoutePlayerMsgStringResponse& from) : RoutePlayerMsgStringResponse(nullptr, from) {}
  inline RoutePlayerMsgStringResponse(RoutePlayerMsgStringResponse&& from) noexcept
      : RoutePlayerMsgStringResponse(nullptr, std::move(from)) {}
  inline RoutePlayerMsgStringResponse& operator=(const RoutePlayerMsgStringResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutePlayerMsgStringResponse& operator=(RoutePlayerMsgStringResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutePlayerMsgStringResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutePlayerMsgStringResponse* internal_default_instance() {
    return reinterpret_cast<const RoutePlayerMsgStringResponse*>(
        &_RoutePlayerMsgStringResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(RoutePlayerMsgStringResponse& a, RoutePlayerMsgStringResponse& b) { a.Swap(&b); }
  inline void Swap(RoutePlayerMsgStringResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutePlayerMsgStringResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutePlayerMsgStringResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RoutePlayerMsgStringResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoutePlayerMsgStringResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoutePlayerMsgStringResponse& from) { RoutePlayerMsgStringResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoutePlayerMsgStringResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RoutePlayerMsgStringResponse"; }

 protected:
  explicit RoutePlayerMsgStringResponse(::google::protobuf::Arena* arena);
  RoutePlayerMsgStringResponse(::google::protobuf::Arena* arena, const RoutePlayerMsgStringResponse& from);
  RoutePlayerMsgStringResponse(::google::protobuf::Arena* arena, RoutePlayerMsgStringResponse&& from) noexcept
      : RoutePlayerMsgStringResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeListFieldNumber = 2,
    kBodyFieldNumber = 1,
    kPlayerExFieldNumber = 3,
  };
  // repeated .NodeInfo node_list = 2;
  int node_list_size() const;
  private:
  int _internal_node_list_size() const;

  public:
  void clear_node_list() ;
  ::NodeInfo* mutable_node_list(int index);
  ::google::protobuf::RepeatedPtrField<::NodeInfo>* mutable_node_list();

  private:
  const ::google::protobuf::RepeatedPtrField<::NodeInfo>& _internal_node_list() const;
  ::google::protobuf::RepeatedPtrField<::NodeInfo>* _internal_mutable_node_list();
  public:
  const ::NodeInfo& node_list(int index) const;
  ::NodeInfo* add_node_list();
  const ::google::protobuf::RepeatedPtrField<::NodeInfo>& node_list() const;
  // bytes body = 1;
  void clear_body() ;
  const std::string& body() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_body(Arg_&& arg, Args_... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* value);

  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(
      const std::string& value);
  std::string* _internal_mutable_body();

  public:
  // .PlayerMessageExtern player_ex = 3;
  bool has_player_ex() const;
  void clear_player_ex() ;
  const ::PlayerMessageExtern& player_ex() const;
  PROTOBUF_NODISCARD ::PlayerMessageExtern* release_player_ex();
  ::PlayerMessageExtern* mutable_player_ex();
  void set_allocated_player_ex(::PlayerMessageExtern* value);
  void unsafe_arena_set_allocated_player_ex(::PlayerMessageExtern* value);
  ::PlayerMessageExtern* unsafe_arena_release_player_ex();

  private:
  const ::PlayerMessageExtern& _internal_player_ex() const;
  ::PlayerMessageExtern* _internal_mutable_player_ex();

  public:
  // @@protoc_insertion_point(class_scope:RoutePlayerMsgStringResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NodeInfo > node_list_;
    ::google::protobuf::internal::ArenaStringPtr body_;
    ::PlayerMessageExtern* player_ex_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RoutePlayerMsgStringRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RoutePlayerMsgStringRequest) */ {
 public:
  inline RoutePlayerMsgStringRequest() : RoutePlayerMsgStringRequest(nullptr) {}
  ~RoutePlayerMsgStringRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoutePlayerMsgStringRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RoutePlayerMsgStringRequest(const RoutePlayerMsgStringRequest& from) : RoutePlayerMsgStringRequest(nullptr, from) {}
  inline RoutePlayerMsgStringRequest(RoutePlayerMsgStringRequest&& from) noexcept
      : RoutePlayerMsgStringRequest(nullptr, std::move(from)) {}
  inline RoutePlayerMsgStringRequest& operator=(const RoutePlayerMsgStringRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutePlayerMsgStringRequest& operator=(RoutePlayerMsgStringRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutePlayerMsgStringRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutePlayerMsgStringRequest* internal_default_instance() {
    return reinterpret_cast<const RoutePlayerMsgStringRequest*>(
        &_RoutePlayerMsgStringRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(RoutePlayerMsgStringRequest& a, RoutePlayerMsgStringRequest& b) { a.Swap(&b); }
  inline void Swap(RoutePlayerMsgStringRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutePlayerMsgStringRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutePlayerMsgStringRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RoutePlayerMsgStringRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoutePlayerMsgStringRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoutePlayerMsgStringRequest& from) { RoutePlayerMsgStringRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoutePlayerMsgStringRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RoutePlayerMsgStringRequest"; }

 protected:
  explicit RoutePlayerMsgStringRequest(::google::protobuf::Arena* arena);
  RoutePlayerMsgStringRequest(::google::protobuf::Arena* arena, const RoutePlayerMsgStringRequest& from);
  RoutePlayerMsgStringRequest(::google::protobuf::Arena* arena, RoutePlayerMsgStringRequest&& from) noexcept
      : RoutePlayerMsgStringRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeListFieldNumber = 2,
    kBodyFieldNumber = 1,
    kPlayerExFieldNumber = 3,
  };
  // repeated .NodeInfo node_list = 2;
  int node_list_size() const;
  private:
  int _internal_node_list_size() const;

  public:
  void clear_node_list() ;
  ::NodeInfo* mutable_node_list(int index);
  ::google::protobuf::RepeatedPtrField<::NodeInfo>* mutable_node_list();

  private:
  const ::google::protobuf::RepeatedPtrField<::NodeInfo>& _internal_node_list() const;
  ::google::protobuf::RepeatedPtrField<::NodeInfo>* _internal_mutable_node_list();
  public:
  const ::NodeInfo& node_list(int index) const;
  ::NodeInfo* add_node_list();
  const ::google::protobuf::RepeatedPtrField<::NodeInfo>& node_list() const;
  // bytes body = 1;
  void clear_body() ;
  const std::string& body() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_body(Arg_&& arg, Args_... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* value);

  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(
      const std::string& value);
  std::string* _internal_mutable_body();

  public:
  // .PlayerMessageExtern player_ex = 3;
  bool has_player_ex() const;
  void clear_player_ex() ;
  const ::PlayerMessageExtern& player_ex() const;
  PROTOBUF_NODISCARD ::PlayerMessageExtern* release_player_ex();
  ::PlayerMessageExtern* mutable_player_ex();
  void set_allocated_player_ex(::PlayerMessageExtern* value);
  void unsafe_arena_set_allocated_player_ex(::PlayerMessageExtern* value);
  ::PlayerMessageExtern* unsafe_arena_release_player_ex();

  private:
  const ::PlayerMessageExtern& _internal_player_ex() const;
  ::PlayerMessageExtern* _internal_mutable_player_ex();

  public:
  // @@protoc_insertion_point(class_scope:RoutePlayerMsgStringRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NodeInfo > node_list_;
    ::google::protobuf::internal::ArenaStringPtr body_;
    ::PlayerMessageExtern* player_ex_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RouteNodeInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RouteNodeInfo) */ {
 public:
  inline RouteNodeInfo() : RouteNodeInfo(nullptr) {}
  ~RouteNodeInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RouteNodeInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline RouteNodeInfo(const RouteNodeInfo& from) : RouteNodeInfo(nullptr, from) {}
  inline RouteNodeInfo(RouteNodeInfo&& from) noexcept
      : RouteNodeInfo(nullptr, std::move(from)) {}
  inline RouteNodeInfo& operator=(const RouteNodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteNodeInfo& operator=(RouteNodeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteNodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteNodeInfo* internal_default_instance() {
    return reinterpret_cast<const RouteNodeInfo*>(
        &_RouteNodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(RouteNodeInfo& a, RouteNodeInfo& b) { a.Swap(&b); }
  inline void Swap(RouteNodeInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteNodeInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteNodeInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RouteNodeInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouteNodeInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RouteNodeInfo& from) { RouteNodeInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouteNodeInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RouteNodeInfo"; }

 protected:
  explicit RouteNodeInfo(::google::protobuf::Arena* arena);
  RouteNodeInfo(::google::protobuf::Arena* arena, const RouteNodeInfo& from);
  RouteNodeInfo(::google::protobuf::Arena* arena, RouteNodeInfo&& from) noexcept
      : RouteNodeInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeInfoFieldNumber = 1,
    kMessageIdFieldNumber = 2,
  };
  // .NodeInfo node_info = 1;
  bool has_node_info() const;
  void clear_node_info() ;
  const ::NodeInfo& node_info() const;
  PROTOBUF_NODISCARD ::NodeInfo* release_node_info();
  ::NodeInfo* mutable_node_info();
  void set_allocated_node_info(::NodeInfo* value);
  void unsafe_arena_set_allocated_node_info(::NodeInfo* value);
  ::NodeInfo* unsafe_arena_release_node_info();

  private:
  const ::NodeInfo& _internal_node_info() const;
  ::NodeInfo* _internal_mutable_node_info();

  public:
  // uint32 message_id = 2;
  void clear_message_id() ;
  ::uint32_t message_id() const;
  void set_message_id(::uint32_t value);

  private:
  ::uint32_t _internal_message_id() const;
  void _internal_set_message_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:RouteNodeInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::NodeInfo* node_info_;
    ::uint32_t message_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RegisterSessionGateNodeResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RegisterSessionGateNodeResponse) */ {
 public:
  inline RegisterSessionGateNodeResponse() : RegisterSessionGateNodeResponse(nullptr) {}
  ~RegisterSessionGateNodeResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterSessionGateNodeResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterSessionGateNodeResponse(const RegisterSessionGateNodeResponse& from) : RegisterSessionGateNodeResponse(nullptr, from) {}
  inline RegisterSessionGateNodeResponse(RegisterSessionGateNodeResponse&& from) noexcept
      : RegisterSessionGateNodeResponse(nullptr, std::move(from)) {}
  inline RegisterSessionGateNodeResponse& operator=(const RegisterSessionGateNodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterSessionGateNodeResponse& operator=(RegisterSessionGateNodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterSessionGateNodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterSessionGateNodeResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterSessionGateNodeResponse*>(
        &_RegisterSessionGateNodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(RegisterSessionGateNodeResponse& a, RegisterSessionGateNodeResponse& b) { a.Swap(&b); }
  inline void Swap(RegisterSessionGateNodeResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterSessionGateNodeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterSessionGateNodeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterSessionGateNodeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterSessionGateNodeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterSessionGateNodeResponse& from) { RegisterSessionGateNodeResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterSessionGateNodeResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RegisterSessionGateNodeResponse"; }

 protected:
  explicit RegisterSessionGateNodeResponse(::google::protobuf::Arena* arena);
  RegisterSessionGateNodeResponse(::google::protobuf::Arena* arena, const RegisterSessionGateNodeResponse& from);
  RegisterSessionGateNodeResponse(::google::protobuf::Arena* arena, RegisterSessionGateNodeResponse&& from) noexcept
      : RegisterSessionGateNodeResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionInfoFieldNumber = 1,
  };
  // .SessionDetails session_info = 1;
  bool has_session_info() const;
  void clear_session_info() ;
  const ::SessionDetails& session_info() const;
  PROTOBUF_NODISCARD ::SessionDetails* release_session_info();
  ::SessionDetails* mutable_session_info();
  void set_allocated_session_info(::SessionDetails* value);
  void unsafe_arena_set_allocated_session_info(::SessionDetails* value);
  ::SessionDetails* unsafe_arena_release_session_info();

  private:
  const ::SessionDetails& _internal_session_info() const;
  ::SessionDetails* _internal_mutable_session_info();

  public:
  // @@protoc_insertion_point(class_scope:RegisterSessionGateNodeResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::SessionDetails* session_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RegisterSessionCentreNodeResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RegisterSessionCentreNodeResponse) */ {
 public:
  inline RegisterSessionCentreNodeResponse() : RegisterSessionCentreNodeResponse(nullptr) {}
  ~RegisterSessionCentreNodeResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterSessionCentreNodeResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterSessionCentreNodeResponse(const RegisterSessionCentreNodeResponse& from) : RegisterSessionCentreNodeResponse(nullptr, from) {}
  inline RegisterSessionCentreNodeResponse(RegisterSessionCentreNodeResponse&& from) noexcept
      : RegisterSessionCentreNodeResponse(nullptr, std::move(from)) {}
  inline RegisterSessionCentreNodeResponse& operator=(const RegisterSessionCentreNodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterSessionCentreNodeResponse& operator=(RegisterSessionCentreNodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterSessionCentreNodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterSessionCentreNodeResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterSessionCentreNodeResponse*>(
        &_RegisterSessionCentreNodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(RegisterSessionCentreNodeResponse& a, RegisterSessionCentreNodeResponse& b) { a.Swap(&b); }
  inline void Swap(RegisterSessionCentreNodeResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterSessionCentreNodeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterSessionCentreNodeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterSessionCentreNodeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterSessionCentreNodeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterSessionCentreNodeResponse& from) { RegisterSessionCentreNodeResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterSessionCentreNodeResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RegisterSessionCentreNodeResponse"; }

 protected:
  explicit RegisterSessionCentreNodeResponse(::google::protobuf::Arena* arena);
  RegisterSessionCentreNodeResponse(::google::protobuf::Arena* arena, const RegisterSessionCentreNodeResponse& from);
  RegisterSessionCentreNodeResponse(::google::protobuf::Arena* arena, RegisterSessionCentreNodeResponse&& from) noexcept
      : RegisterSessionCentreNodeResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionInfoFieldNumber = 1,
  };
  // .SessionDetails session_info = 1;
  bool has_session_info() const;
  void clear_session_info() ;
  const ::SessionDetails& session_info() const;
  PROTOBUF_NODISCARD ::SessionDetails* release_session_info();
  ::SessionDetails* mutable_session_info();
  void set_allocated_session_info(::SessionDetails* value);
  void unsafe_arena_set_allocated_session_info(::SessionDetails* value);
  ::SessionDetails* unsafe_arena_release_session_info();

  private:
  const ::SessionDetails& _internal_session_info() const;
  ::SessionDetails* _internal_mutable_session_info();

  public:
  // @@protoc_insertion_point(class_scope:RegisterSessionCentreNodeResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::SessionDetails* session_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RegisterGateNodeRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RegisterGateNodeRequest) */ {
 public:
  inline RegisterGateNodeRequest() : RegisterGateNodeRequest(nullptr) {}
  ~RegisterGateNodeRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterGateNodeRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterGateNodeRequest(const RegisterGateNodeRequest& from) : RegisterGateNodeRequest(nullptr, from) {}
  inline RegisterGateNodeRequest(RegisterGateNodeRequest&& from) noexcept
      : RegisterGateNodeRequest(nullptr, std::move(from)) {}
  inline RegisterGateNodeRequest& operator=(const RegisterGateNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterGateNodeRequest& operator=(RegisterGateNodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterGateNodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterGateNodeRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterGateNodeRequest*>(
        &_RegisterGateNodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(RegisterGateNodeRequest& a, RegisterGateNodeRequest& b) { a.Swap(&b); }
  inline void Swap(RegisterGateNodeRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterGateNodeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterGateNodeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterGateNodeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterGateNodeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterGateNodeRequest& from) { RegisterGateNodeRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterGateNodeRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RegisterGateNodeRequest"; }

 protected:
  explicit RegisterGateNodeRequest(::google::protobuf::Arena* arena);
  RegisterGateNodeRequest(::google::protobuf::Arena* arena, const RegisterGateNodeRequest& from);
  RegisterGateNodeRequest(::google::protobuf::Arena* arena, RegisterGateNodeRequest&& from) noexcept
      : RegisterGateNodeRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRpcClientFieldNumber = 1,
    kGateNodeIdFieldNumber = 2,
  };
  // .NetworkAddress rpc_client = 1;
  bool has_rpc_client() const;
  void clear_rpc_client() ;
  const ::NetworkAddress& rpc_client() const;
  PROTOBUF_NODISCARD ::NetworkAddress* release_rpc_client();
  ::NetworkAddress* mutable_rpc_client();
  void set_allocated_rpc_client(::NetworkAddress* value);
  void unsafe_arena_set_allocated_rpc_client(::NetworkAddress* value);
  ::NetworkAddress* unsafe_arena_release_rpc_client();

  private:
  const ::NetworkAddress& _internal_rpc_client() const;
  ::NetworkAddress* _internal_mutable_rpc_client();

  public:
  // uint32 gate_node_id = 2;
  void clear_gate_node_id() ;
  ::uint32_t gate_node_id() const;
  void set_gate_node_id(::uint32_t value);

  private:
  ::uint32_t _internal_gate_node_id() const;
  void _internal_set_gate_node_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:RegisterGateNodeRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::NetworkAddress* rpc_client_;
    ::uint32_t gate_node_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RegisterGameNodeSessionResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RegisterGameNodeSessionResponse) */ {
 public:
  inline RegisterGameNodeSessionResponse() : RegisterGameNodeSessionResponse(nullptr) {}
  ~RegisterGameNodeSessionResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterGameNodeSessionResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterGameNodeSessionResponse(const RegisterGameNodeSessionResponse& from) : RegisterGameNodeSessionResponse(nullptr, from) {}
  inline RegisterGameNodeSessionResponse(RegisterGameNodeSessionResponse&& from) noexcept
      : RegisterGameNodeSessionResponse(nullptr, std::move(from)) {}
  inline RegisterGameNodeSessionResponse& operator=(const RegisterGameNodeSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterGameNodeSessionResponse& operator=(RegisterGameNodeSessionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterGameNodeSessionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterGameNodeSessionResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterGameNodeSessionResponse*>(
        &_RegisterGameNodeSessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(RegisterGameNodeSessionResponse& a, RegisterGameNodeSessionResponse& b) { a.Swap(&b); }
  inline void Swap(RegisterGameNodeSessionResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterGameNodeSessionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterGameNodeSessionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterGameNodeSessionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterGameNodeSessionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterGameNodeSessionResponse& from) { RegisterGameNodeSessionResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterGameNodeSessionResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RegisterGameNodeSessionResponse"; }

 protected:
  explicit RegisterGameNodeSessionResponse(::google::protobuf::Arena* arena);
  RegisterGameNodeSessionResponse(::google::protobuf::Arena* arena, const RegisterGameNodeSessionResponse& from);
  RegisterGameNodeSessionResponse(::google::protobuf::Arena* arena, RegisterGameNodeSessionResponse&& from) noexcept
      : RegisterGameNodeSessionResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionInfoFieldNumber = 1,
  };
  // .SessionDetails session_info = 1;
  bool has_session_info() const;
  void clear_session_info() ;
  const ::SessionDetails& session_info() const;
  PROTOBUF_NODISCARD ::SessionDetails* release_session_info();
  ::SessionDetails* mutable_session_info();
  void set_allocated_session_info(::SessionDetails* value);
  void unsafe_arena_set_allocated_session_info(::SessionDetails* value);
  ::SessionDetails* unsafe_arena_release_session_info();

  private:
  const ::SessionDetails& _internal_session_info() const;
  ::SessionDetails* _internal_mutable_session_info();

  public:
  // @@protoc_insertion_point(class_scope:RegisterGameNodeSessionResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::SessionDetails* session_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RegisterGameNodeSessionRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RegisterGameNodeSessionRequest) */ {
 public:
  inline RegisterGameNodeSessionRequest() : RegisterGameNodeSessionRequest(nullptr) {}
  ~RegisterGameNodeSessionRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterGameNodeSessionRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterGameNodeSessionRequest(const RegisterGameNodeSessionRequest& from) : RegisterGameNodeSessionRequest(nullptr, from) {}
  inline RegisterGameNodeSessionRequest(RegisterGameNodeSessionRequest&& from) noexcept
      : RegisterGameNodeSessionRequest(nullptr, std::move(from)) {}
  inline RegisterGameNodeSessionRequest& operator=(const RegisterGameNodeSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterGameNodeSessionRequest& operator=(RegisterGameNodeSessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterGameNodeSessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterGameNodeSessionRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterGameNodeSessionRequest*>(
        &_RegisterGameNodeSessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(RegisterGameNodeSessionRequest& a, RegisterGameNodeSessionRequest& b) { a.Swap(&b); }
  inline void Swap(RegisterGameNodeSessionRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterGameNodeSessionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterGameNodeSessionRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterGameNodeSessionRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterGameNodeSessionRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterGameNodeSessionRequest& from) { RegisterGameNodeSessionRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterGameNodeSessionRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RegisterGameNodeSessionRequest"; }

 protected:
  explicit RegisterGameNodeSessionRequest(::google::protobuf::Arena* arena);
  RegisterGameNodeSessionRequest(::google::protobuf::Arena* arena, const RegisterGameNodeSessionRequest& from);
  RegisterGameNodeSessionRequest(::google::protobuf::Arena* arena, RegisterGameNodeSessionRequest&& from) noexcept
      : RegisterGameNodeSessionRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionInfoFieldNumber = 1,
    kGameNodeIdFieldNumber = 2,
  };
  // .SessionDetails session_info = 1;
  bool has_session_info() const;
  void clear_session_info() ;
  const ::SessionDetails& session_info() const;
  PROTOBUF_NODISCARD ::SessionDetails* release_session_info();
  ::SessionDetails* mutable_session_info();
  void set_allocated_session_info(::SessionDetails* value);
  void unsafe_arena_set_allocated_session_info(::SessionDetails* value);
  ::SessionDetails* unsafe_arena_release_session_info();

  private:
  const ::SessionDetails& _internal_session_info() const;
  ::SessionDetails* _internal_mutable_session_info();

  public:
  // uint32 game_node_id = 2;
  void clear_game_node_id() ;
  ::uint32_t game_node_id() const;
  void set_game_node_id(::uint32_t value);

  private:
  ::uint32_t _internal_game_node_id() const;
  void _internal_set_game_node_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:RegisterGameNodeSessionRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::SessionDetails* session_info_;
    ::uint32_t game_node_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RegisterGameNodeRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RegisterGameNodeRequest) */ {
 public:
  inline RegisterGameNodeRequest() : RegisterGameNodeRequest(nullptr) {}
  ~RegisterGameNodeRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterGameNodeRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterGameNodeRequest(const RegisterGameNodeRequest& from) : RegisterGameNodeRequest(nullptr, from) {}
  inline RegisterGameNodeRequest(RegisterGameNodeRequest&& from) noexcept
      : RegisterGameNodeRequest(nullptr, std::move(from)) {}
  inline RegisterGameNodeRequest& operator=(const RegisterGameNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterGameNodeRequest& operator=(RegisterGameNodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterGameNodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterGameNodeRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterGameNodeRequest*>(
        &_RegisterGameNodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(RegisterGameNodeRequest& a, RegisterGameNodeRequest& b) { a.Swap(&b); }
  inline void Swap(RegisterGameNodeRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterGameNodeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterGameNodeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterGameNodeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterGameNodeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterGameNodeRequest& from) { RegisterGameNodeRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterGameNodeRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RegisterGameNodeRequest"; }

 protected:
  explicit RegisterGameNodeRequest(::google::protobuf::Arena* arena);
  RegisterGameNodeRequest(::google::protobuf::Arena* arena, const RegisterGameNodeRequest& from);
  RegisterGameNodeRequest(::google::protobuf::Arena* arena, RegisterGameNodeRequest&& from) noexcept
      : RegisterGameNodeRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRpcClientFieldNumber = 1,
    kRpcServerFieldNumber = 2,
    kGameNodeIdFieldNumber = 3,
    kServerTypeFieldNumber = 4,
  };
  // .NetworkAddress rpc_client = 1;
  bool has_rpc_client() const;
  void clear_rpc_client() ;
  const ::NetworkAddress& rpc_client() const;
  PROTOBUF_NODISCARD ::NetworkAddress* release_rpc_client();
  ::NetworkAddress* mutable_rpc_client();
  void set_allocated_rpc_client(::NetworkAddress* value);
  void unsafe_arena_set_allocated_rpc_client(::NetworkAddress* value);
  ::NetworkAddress* unsafe_arena_release_rpc_client();

  private:
  const ::NetworkAddress& _internal_rpc_client() const;
  ::NetworkAddress* _internal_mutable_rpc_client();

  public:
  // .NetworkAddress rpc_server = 2;
  bool has_rpc_server() const;
  void clear_rpc_server() ;
  const ::NetworkAddress& rpc_server() const;
  PROTOBUF_NODISCARD ::NetworkAddress* release_rpc_server();
  ::NetworkAddress* mutable_rpc_server();
  void set_allocated_rpc_server(::NetworkAddress* value);
  void unsafe_arena_set_allocated_rpc_server(::NetworkAddress* value);
  ::NetworkAddress* unsafe_arena_release_rpc_server();

  private:
  const ::NetworkAddress& _internal_rpc_server() const;
  ::NetworkAddress* _internal_mutable_rpc_server();

  public:
  // uint32 game_node_id = 3;
  void clear_game_node_id() ;
  ::uint32_t game_node_id() const;
  void set_game_node_id(::uint32_t value);

  private:
  ::uint32_t _internal_game_node_id() const;
  void _internal_set_game_node_id(::uint32_t value);

  public:
  // uint32 server_type = 4;
  void clear_server_type() ;
  ::uint32_t server_type() const;
  void set_server_type(::uint32_t value);

  private:
  ::uint32_t _internal_server_type() const;
  void _internal_set_server_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:RegisterGameNodeRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::NetworkAddress* rpc_client_;
    ::NetworkAddress* rpc_server_;
    ::uint32_t game_node_id_;
    ::uint32_t server_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RegisterCentreSessionNodeRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RegisterCentreSessionNodeRequest) */ {
 public:
  inline RegisterCentreSessionNodeRequest() : RegisterCentreSessionNodeRequest(nullptr) {}
  ~RegisterCentreSessionNodeRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterCentreSessionNodeRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterCentreSessionNodeRequest(const RegisterCentreSessionNodeRequest& from) : RegisterCentreSessionNodeRequest(nullptr, from) {}
  inline RegisterCentreSessionNodeRequest(RegisterCentreSessionNodeRequest&& from) noexcept
      : RegisterCentreSessionNodeRequest(nullptr, std::move(from)) {}
  inline RegisterCentreSessionNodeRequest& operator=(const RegisterCentreSessionNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterCentreSessionNodeRequest& operator=(RegisterCentreSessionNodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterCentreSessionNodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterCentreSessionNodeRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterCentreSessionNodeRequest*>(
        &_RegisterCentreSessionNodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(RegisterCentreSessionNodeRequest& a, RegisterCentreSessionNodeRequest& b) { a.Swap(&b); }
  inline void Swap(RegisterCentreSessionNodeRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterCentreSessionNodeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterCentreSessionNodeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterCentreSessionNodeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterCentreSessionNodeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterCentreSessionNodeRequest& from) { RegisterCentreSessionNodeRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterCentreSessionNodeRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RegisterCentreSessionNodeRequest"; }

 protected:
  explicit RegisterCentreSessionNodeRequest(::google::protobuf::Arena* arena);
  RegisterCentreSessionNodeRequest(::google::protobuf::Arena* arena, const RegisterCentreSessionNodeRequest& from);
  RegisterCentreSessionNodeRequest(::google::protobuf::Arena* arena, RegisterCentreSessionNodeRequest&& from) noexcept
      : RegisterCentreSessionNodeRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionInfoFieldNumber = 1,
    kCentreNodeIdFieldNumber = 2,
  };
  // .SessionDetails session_info = 1;
  bool has_session_info() const;
  void clear_session_info() ;
  const ::SessionDetails& session_info() const;
  PROTOBUF_NODISCARD ::SessionDetails* release_session_info();
  ::SessionDetails* mutable_session_info();
  void set_allocated_session_info(::SessionDetails* value);
  void unsafe_arena_set_allocated_session_info(::SessionDetails* value);
  ::SessionDetails* unsafe_arena_release_session_info();

  private:
  const ::SessionDetails& _internal_session_info() const;
  ::SessionDetails* _internal_mutable_session_info();

  public:
  // uint32 centre_node_id = 2;
  void clear_centre_node_id() ;
  ::uint32_t centre_node_id() const;
  void set_centre_node_id(::uint32_t value);

  private:
  ::uint32_t _internal_centre_node_id() const;
  void _internal_set_centre_node_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:RegisterCentreSessionNodeRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::SessionDetails* session_info_;
    ::uint32_t centre_node_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class PlayerNodeServiceRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PlayerNodeServiceRequest) */ {
 public:
  inline PlayerNodeServiceRequest() : PlayerNodeServiceRequest(nullptr) {}
  ~PlayerNodeServiceRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerNodeServiceRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerNodeServiceRequest(const PlayerNodeServiceRequest& from) : PlayerNodeServiceRequest(nullptr, from) {}
  inline PlayerNodeServiceRequest(PlayerNodeServiceRequest&& from) noexcept
      : PlayerNodeServiceRequest(nullptr, std::move(from)) {}
  inline PlayerNodeServiceRequest& operator=(const PlayerNodeServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerNodeServiceRequest& operator=(PlayerNodeServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerNodeServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerNodeServiceRequest* internal_default_instance() {
    return reinterpret_cast<const PlayerNodeServiceRequest*>(
        &_PlayerNodeServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(PlayerNodeServiceRequest& a, PlayerNodeServiceRequest& b) { a.Swap(&b); }
  inline void Swap(PlayerNodeServiceRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerNodeServiceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerNodeServiceRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlayerNodeServiceRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerNodeServiceRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerNodeServiceRequest& from) { PlayerNodeServiceRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerNodeServiceRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PlayerNodeServiceRequest"; }

 protected:
  explicit PlayerNodeServiceRequest(::google::protobuf::Arena* arena);
  PlayerNodeServiceRequest(::google::protobuf::Arena* arena, const PlayerNodeServiceRequest& from);
  PlayerNodeServiceRequest(::google::protobuf::Arena* arena, PlayerNodeServiceRequest&& from) noexcept
      : PlayerNodeServiceRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBodyFieldNumber = 1,
    kHeadFieldNumber = 2,
  };
  // .MessageBody body = 1;
  bool has_body() const;
  void clear_body() ;
  const ::MessageBody& body() const;
  PROTOBUF_NODISCARD ::MessageBody* release_body();
  ::MessageBody* mutable_body();
  void set_allocated_body(::MessageBody* value);
  void unsafe_arena_set_allocated_body(::MessageBody* value);
  ::MessageBody* unsafe_arena_release_body();

  private:
  const ::MessageBody& _internal_body() const;
  ::MessageBody* _internal_mutable_body();

  public:
  // .PlayerMessageExtern head = 2;
  bool has_head() const;
  void clear_head() ;
  const ::PlayerMessageExtern& head() const;
  PROTOBUF_NODISCARD ::PlayerMessageExtern* release_head();
  ::PlayerMessageExtern* mutable_head();
  void set_allocated_head(::PlayerMessageExtern* value);
  void unsafe_arena_set_allocated_head(::PlayerMessageExtern* value);
  ::PlayerMessageExtern* unsafe_arena_release_head();

  private:
  const ::PlayerMessageExtern& _internal_head() const;
  ::PlayerMessageExtern* _internal_mutable_head();

  public:
  // @@protoc_insertion_point(class_scope:PlayerNodeServiceRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::MessageBody* body_;
    ::PlayerMessageExtern* head_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class PlayerMessageResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PlayerMessageResponse) */ {
 public:
  inline PlayerMessageResponse() : PlayerMessageResponse(nullptr) {}
  ~PlayerMessageResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerMessageResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerMessageResponse(const PlayerMessageResponse& from) : PlayerMessageResponse(nullptr, from) {}
  inline PlayerMessageResponse(PlayerMessageResponse&& from) noexcept
      : PlayerMessageResponse(nullptr, std::move(from)) {}
  inline PlayerMessageResponse& operator=(const PlayerMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerMessageResponse& operator=(PlayerMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerMessageResponse* internal_default_instance() {
    return reinterpret_cast<const PlayerMessageResponse*>(
        &_PlayerMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(PlayerMessageResponse& a, PlayerMessageResponse& b) { a.Swap(&b); }
  inline void Swap(PlayerMessageResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerMessageResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerMessageResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlayerMessageResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerMessageResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerMessageResponse& from) { PlayerMessageResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerMessageResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PlayerMessageResponse"; }

 protected:
  explicit PlayerMessageResponse(::google::protobuf::Arena* arena);
  PlayerMessageResponse(::google::protobuf::Arena* arena, const PlayerMessageResponse& from);
  PlayerMessageResponse(::google::protobuf::Arena* arena, PlayerMessageResponse&& from) noexcept
      : PlayerMessageResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBodyFieldNumber = 1,
    kHeadFieldNumber = 2,
  };
  // .MessageBody body = 1;
  bool has_body() const;
  void clear_body() ;
  const ::MessageBody& body() const;
  PROTOBUF_NODISCARD ::MessageBody* release_body();
  ::MessageBody* mutable_body();
  void set_allocated_body(::MessageBody* value);
  void unsafe_arena_set_allocated_body(::MessageBody* value);
  ::MessageBody* unsafe_arena_release_body();

  private:
  const ::MessageBody& _internal_body() const;
  ::MessageBody* _internal_mutable_body();

  public:
  // .PlayerMessageExtern head = 2;
  bool has_head() const;
  void clear_head() ;
  const ::PlayerMessageExtern& head() const;
  PROTOBUF_NODISCARD ::PlayerMessageExtern* release_head();
  ::PlayerMessageExtern* mutable_head();
  void set_allocated_head(::PlayerMessageExtern* value);
  void unsafe_arena_set_allocated_head(::PlayerMessageExtern* value);
  ::PlayerMessageExtern* unsafe_arena_release_head();

  private:
  const ::PlayerMessageExtern& _internal_head() const;
  ::PlayerMessageExtern* _internal_mutable_head();

  public:
  // @@protoc_insertion_point(class_scope:PlayerMessageResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::MessageBody* body_;
    ::PlayerMessageExtern* head_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class NodeRouteMessageResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NodeRouteMessageResponse) */ {
 public:
  inline NodeRouteMessageResponse() : NodeRouteMessageResponse(nullptr) {}
  ~NodeRouteMessageResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeRouteMessageResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeRouteMessageResponse(const NodeRouteMessageResponse& from) : NodeRouteMessageResponse(nullptr, from) {}
  inline NodeRouteMessageResponse(NodeRouteMessageResponse&& from) noexcept
      : NodeRouteMessageResponse(nullptr, std::move(from)) {}
  inline NodeRouteMessageResponse& operator=(const NodeRouteMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeRouteMessageResponse& operator=(NodeRouteMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeRouteMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeRouteMessageResponse* internal_default_instance() {
    return reinterpret_cast<const NodeRouteMessageResponse*>(
        &_NodeRouteMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(NodeRouteMessageResponse& a, NodeRouteMessageResponse& b) { a.Swap(&b); }
  inline void Swap(NodeRouteMessageResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeRouteMessageResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeRouteMessageResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NodeRouteMessageResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeRouteMessageResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeRouteMessageResponse& from) { NodeRouteMessageResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeRouteMessageResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "NodeRouteMessageResponse"; }

 protected:
  explicit NodeRouteMessageResponse(::google::protobuf::Arena* arena);
  NodeRouteMessageResponse(::google::protobuf::Arena* arena, const NodeRouteMessageResponse& from);
  NodeRouteMessageResponse(::google::protobuf::Arena* arena, NodeRouteMessageResponse&& from) noexcept
      : NodeRouteMessageResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBodyFieldNumber = 1,
    kHeadFieldNumber = 2,
  };
  // .MessageBody body = 1;
  bool has_body() const;
  void clear_body() ;
  const ::MessageBody& body() const;
  PROTOBUF_NODISCARD ::MessageBody* release_body();
  ::MessageBody* mutable_body();
  void set_allocated_body(::MessageBody* value);
  void unsafe_arena_set_allocated_body(::MessageBody* value);
  ::MessageBody* unsafe_arena_release_body();

  private:
  const ::MessageBody& _internal_body() const;
  ::MessageBody* _internal_mutable_body();

  public:
  // .NodeMessageHead head = 2;
  bool has_head() const;
  void clear_head() ;
  const ::NodeMessageHead& head() const;
  PROTOBUF_NODISCARD ::NodeMessageHead* release_head();
  ::NodeMessageHead* mutable_head();
  void set_allocated_head(::NodeMessageHead* value);
  void unsafe_arena_set_allocated_head(::NodeMessageHead* value);
  ::NodeMessageHead* unsafe_arena_release_head();

  private:
  const ::NodeMessageHead& _internal_head() const;
  ::NodeMessageHead* _internal_mutable_head();

  public:
  // @@protoc_insertion_point(class_scope:NodeRouteMessageResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::MessageBody* body_;
    ::NodeMessageHead* head_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class NodeRouteMessageRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NodeRouteMessageRequest) */ {
 public:
  inline NodeRouteMessageRequest() : NodeRouteMessageRequest(nullptr) {}
  ~NodeRouteMessageRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeRouteMessageRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeRouteMessageRequest(const NodeRouteMessageRequest& from) : NodeRouteMessageRequest(nullptr, from) {}
  inline NodeRouteMessageRequest(NodeRouteMessageRequest&& from) noexcept
      : NodeRouteMessageRequest(nullptr, std::move(from)) {}
  inline NodeRouteMessageRequest& operator=(const NodeRouteMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeRouteMessageRequest& operator=(NodeRouteMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeRouteMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeRouteMessageRequest* internal_default_instance() {
    return reinterpret_cast<const NodeRouteMessageRequest*>(
        &_NodeRouteMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(NodeRouteMessageRequest& a, NodeRouteMessageRequest& b) { a.Swap(&b); }
  inline void Swap(NodeRouteMessageRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeRouteMessageRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeRouteMessageRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NodeRouteMessageRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeRouteMessageRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeRouteMessageRequest& from) { NodeRouteMessageRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeRouteMessageRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "NodeRouteMessageRequest"; }

 protected:
  explicit NodeRouteMessageRequest(::google::protobuf::Arena* arena);
  NodeRouteMessageRequest(::google::protobuf::Arena* arena, const NodeRouteMessageRequest& from);
  NodeRouteMessageRequest(::google::protobuf::Arena* arena, NodeRouteMessageRequest&& from) noexcept
      : NodeRouteMessageRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBodyFieldNumber = 1,
    kHeadFieldNumber = 2,
  };
  // .MessageBody body = 1;
  bool has_body() const;
  void clear_body() ;
  const ::MessageBody& body() const;
  PROTOBUF_NODISCARD ::MessageBody* release_body();
  ::MessageBody* mutable_body();
  void set_allocated_body(::MessageBody* value);
  void unsafe_arena_set_allocated_body(::MessageBody* value);
  ::MessageBody* unsafe_arena_release_body();

  private:
  const ::MessageBody& _internal_body() const;
  ::MessageBody* _internal_mutable_body();

  public:
  // .NodeMessageHead head = 2;
  bool has_head() const;
  void clear_head() ;
  const ::NodeMessageHead& head() const;
  PROTOBUF_NODISCARD ::NodeMessageHead* release_head();
  ::NodeMessageHead* mutable_head();
  void set_allocated_head(::NodeMessageHead* value);
  void unsafe_arena_set_allocated_head(::NodeMessageHead* value);
  ::NodeMessageHead* unsafe_arena_release_head();

  private:
  const ::NodeMessageHead& _internal_head() const;
  ::NodeMessageHead* _internal_mutable_head();

  public:
  // @@protoc_insertion_point(class_scope:NodeRouteMessageRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::MessageBody* body_;
    ::NodeMessageHead* head_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class NodeRouteMessageBody final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NodeRouteMessageBody) */ {
 public:
  inline NodeRouteMessageBody() : NodeRouteMessageBody(nullptr) {}
  ~NodeRouteMessageBody() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeRouteMessageBody(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeRouteMessageBody(const NodeRouteMessageBody& from) : NodeRouteMessageBody(nullptr, from) {}
  inline NodeRouteMessageBody(NodeRouteMessageBody&& from) noexcept
      : NodeRouteMessageBody(nullptr, std::move(from)) {}
  inline NodeRouteMessageBody& operator=(const NodeRouteMessageBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeRouteMessageBody& operator=(NodeRouteMessageBody&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeRouteMessageBody& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeRouteMessageBody* internal_default_instance() {
    return reinterpret_cast<const NodeRouteMessageBody*>(
        &_NodeRouteMessageBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(NodeRouteMessageBody& a, NodeRouteMessageBody& b) { a.Swap(&b); }
  inline void Swap(NodeRouteMessageBody* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeRouteMessageBody* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeRouteMessageBody* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NodeRouteMessageBody>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeRouteMessageBody& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeRouteMessageBody& from) { NodeRouteMessageBody::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeRouteMessageBody* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "NodeRouteMessageBody"; }

 protected:
  explicit NodeRouteMessageBody(::google::protobuf::Arena* arena);
  NodeRouteMessageBody(::google::protobuf::Arena* arena, const NodeRouteMessageBody& from);
  NodeRouteMessageBody(::google::protobuf::Arena* arena, NodeRouteMessageBody&& from) noexcept
      : NodeRouteMessageBody(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeInfoFieldNumber = 2,
  };
  // .NodeInfo node_info = 2;
  bool has_node_info() const;
  void clear_node_info() ;
  const ::NodeInfo& node_info() const;
  PROTOBUF_NODISCARD ::NodeInfo* release_node_info();
  ::NodeInfo* mutable_node_info();
  void set_allocated_node_info(::NodeInfo* value);
  void unsafe_arena_set_allocated_node_info(::NodeInfo* value);
  ::NodeInfo* unsafe_arena_release_node_info();

  private:
  const ::NodeInfo& _internal_node_info() const;
  ::NodeInfo* _internal_mutable_node_info();

  public:
  // @@protoc_insertion_point(class_scope:NodeRouteMessageBody)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::NodeInfo* node_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class GateSessionDisconnectRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GateSessionDisconnectRequest) */ {
 public:
  inline GateSessionDisconnectRequest() : GateSessionDisconnectRequest(nullptr) {}
  ~GateSessionDisconnectRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GateSessionDisconnectRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GateSessionDisconnectRequest(const GateSessionDisconnectRequest& from) : GateSessionDisconnectRequest(nullptr, from) {}
  inline GateSessionDisconnectRequest(GateSessionDisconnectRequest&& from) noexcept
      : GateSessionDisconnectRequest(nullptr, std::move(from)) {}
  inline GateSessionDisconnectRequest& operator=(const GateSessionDisconnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GateSessionDisconnectRequest& operator=(GateSessionDisconnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GateSessionDisconnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GateSessionDisconnectRequest* internal_default_instance() {
    return reinterpret_cast<const GateSessionDisconnectRequest*>(
        &_GateSessionDisconnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(GateSessionDisconnectRequest& a, GateSessionDisconnectRequest& b) { a.Swap(&b); }
  inline void Swap(GateSessionDisconnectRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GateSessionDisconnectRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GateSessionDisconnectRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GateSessionDisconnectRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GateSessionDisconnectRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GateSessionDisconnectRequest& from) { GateSessionDisconnectRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GateSessionDisconnectRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GateSessionDisconnectRequest"; }

 protected:
  explicit GateSessionDisconnectRequest(::google::protobuf::Arena* arena);
  GateSessionDisconnectRequest(::google::protobuf::Arena* arena, const GateSessionDisconnectRequest& from);
  GateSessionDisconnectRequest(::google::protobuf::Arena* arena, GateSessionDisconnectRequest&& from) noexcept
      : GateSessionDisconnectRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionInfoFieldNumber = 1,
  };
  // .SessionDetails session_info = 1;
  bool has_session_info() const;
  void clear_session_info() ;
  const ::SessionDetails& session_info() const;
  PROTOBUF_NODISCARD ::SessionDetails* release_session_info();
  ::SessionDetails* mutable_session_info();
  void set_allocated_session_info(::SessionDetails* value);
  void unsafe_arena_set_allocated_session_info(::SessionDetails* value);
  ::SessionDetails* unsafe_arena_release_session_info();

  private:
  const ::SessionDetails& _internal_session_info() const;
  ::SessionDetails* _internal_mutable_session_info();

  public:
  // @@protoc_insertion_point(class_scope:GateSessionDisconnectRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::SessionDetails* session_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RouteMsgStringResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RouteMsgStringResponse) */ {
 public:
  inline RouteMsgStringResponse() : RouteMsgStringResponse(nullptr) {}
  ~RouteMsgStringResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RouteMsgStringResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RouteMsgStringResponse(const RouteMsgStringResponse& from) : RouteMsgStringResponse(nullptr, from) {}
  inline RouteMsgStringResponse(RouteMsgStringResponse&& from) noexcept
      : RouteMsgStringResponse(nullptr, std::move(from)) {}
  inline RouteMsgStringResponse& operator=(const RouteMsgStringResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteMsgStringResponse& operator=(RouteMsgStringResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteMsgStringResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteMsgStringResponse* internal_default_instance() {
    return reinterpret_cast<const RouteMsgStringResponse*>(
        &_RouteMsgStringResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(RouteMsgStringResponse& a, RouteMsgStringResponse& b) { a.Swap(&b); }
  inline void Swap(RouteMsgStringResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteMsgStringResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteMsgStringResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RouteMsgStringResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouteMsgStringResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RouteMsgStringResponse& from) { RouteMsgStringResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouteMsgStringResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RouteMsgStringResponse"; }

 protected:
  explicit RouteMsgStringResponse(::google::protobuf::Arena* arena);
  RouteMsgStringResponse(::google::protobuf::Arena* arena, const RouteMsgStringResponse& from);
  RouteMsgStringResponse(::google::protobuf::Arena* arena, RouteMsgStringResponse&& from) noexcept
      : RouteMsgStringResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRouteDataListFieldNumber = 2,
    kBodyFieldNumber = 1,
    kSessionIdFieldNumber = 3,
    kIdFieldNumber = 4,
    kIsClientFieldNumber = 5,
  };
  // repeated .RouteNodeInfo route_data_list = 2;
  int route_data_list_size() const;
  private:
  int _internal_route_data_list_size() const;

  public:
  void clear_route_data_list() ;
  ::RouteNodeInfo* mutable_route_data_list(int index);
  ::google::protobuf::RepeatedPtrField<::RouteNodeInfo>* mutable_route_data_list();

  private:
  const ::google::protobuf::RepeatedPtrField<::RouteNodeInfo>& _internal_route_data_list() const;
  ::google::protobuf::RepeatedPtrField<::RouteNodeInfo>* _internal_mutable_route_data_list();
  public:
  const ::RouteNodeInfo& route_data_list(int index) const;
  ::RouteNodeInfo* add_route_data_list();
  const ::google::protobuf::RepeatedPtrField<::RouteNodeInfo>& route_data_list() const;
  // bytes body = 1;
  void clear_body() ;
  const std::string& body() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_body(Arg_&& arg, Args_... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* value);

  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(
      const std::string& value);
  std::string* _internal_mutable_body();

  public:
  // uint64 session_id = 3;
  void clear_session_id() ;
  ::uint64_t session_id() const;
  void set_session_id(::uint64_t value);

  private:
  ::uint64_t _internal_session_id() const;
  void _internal_set_session_id(::uint64_t value);

  public:
  // uint64 id = 4;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // bool is_client = 5;
  void clear_is_client() ;
  bool is_client() const;
  void set_is_client(bool value);

  private:
  bool _internal_is_client() const;
  void _internal_set_is_client(bool value);

  public:
  // @@protoc_insertion_point(class_scope:RouteMsgStringResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::RouteNodeInfo > route_data_list_;
    ::google::protobuf::internal::ArenaStringPtr body_;
    ::uint64_t session_id_;
    ::uint64_t id_;
    bool is_client_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RouteMsgStringRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RouteMsgStringRequest) */ {
 public:
  inline RouteMsgStringRequest() : RouteMsgStringRequest(nullptr) {}
  ~RouteMsgStringRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RouteMsgStringRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RouteMsgStringRequest(const RouteMsgStringRequest& from) : RouteMsgStringRequest(nullptr, from) {}
  inline RouteMsgStringRequest(RouteMsgStringRequest&& from) noexcept
      : RouteMsgStringRequest(nullptr, std::move(from)) {}
  inline RouteMsgStringRequest& operator=(const RouteMsgStringRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteMsgStringRequest& operator=(RouteMsgStringRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteMsgStringRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteMsgStringRequest* internal_default_instance() {
    return reinterpret_cast<const RouteMsgStringRequest*>(
        &_RouteMsgStringRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(RouteMsgStringRequest& a, RouteMsgStringRequest& b) { a.Swap(&b); }
  inline void Swap(RouteMsgStringRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteMsgStringRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteMsgStringRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RouteMsgStringRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouteMsgStringRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RouteMsgStringRequest& from) { RouteMsgStringRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouteMsgStringRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RouteMsgStringRequest"; }

 protected:
  explicit RouteMsgStringRequest(::google::protobuf::Arena* arena);
  RouteMsgStringRequest(::google::protobuf::Arena* arena, const RouteMsgStringRequest& from);
  RouteMsgStringRequest(::google::protobuf::Arena* arena, RouteMsgStringRequest&& from) noexcept
      : RouteMsgStringRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRouteDataListFieldNumber = 2,
    kBodyFieldNumber = 1,
    kSessionIdFieldNumber = 3,
    kIdFieldNumber = 4,
    kIsClientFieldNumber = 5,
  };
  // repeated .RouteNodeInfo route_data_list = 2;
  int route_data_list_size() const;
  private:
  int _internal_route_data_list_size() const;

  public:
  void clear_route_data_list() ;
  ::RouteNodeInfo* mutable_route_data_list(int index);
  ::google::protobuf::RepeatedPtrField<::RouteNodeInfo>* mutable_route_data_list();

  private:
  const ::google::protobuf::RepeatedPtrField<::RouteNodeInfo>& _internal_route_data_list() const;
  ::google::protobuf::RepeatedPtrField<::RouteNodeInfo>* _internal_mutable_route_data_list();
  public:
  const ::RouteNodeInfo& route_data_list(int index) const;
  ::RouteNodeInfo* add_route_data_list();
  const ::google::protobuf::RepeatedPtrField<::RouteNodeInfo>& route_data_list() const;
  // bytes body = 1;
  void clear_body() ;
  const std::string& body() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_body(Arg_&& arg, Args_... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* value);

  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(
      const std::string& value);
  std::string* _internal_mutable_body();

  public:
  // uint64 session_id = 3;
  void clear_session_id() ;
  ::uint64_t session_id() const;
  void set_session_id(::uint64_t value);

  private:
  ::uint64_t _internal_session_id() const;
  void _internal_set_session_id(::uint64_t value);

  public:
  // uint64 id = 4;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // bool is_client = 5;
  void clear_is_client() ;
  bool is_client() const;
  void set_is_client(bool value);

  private:
  bool _internal_is_client() const;
  void _internal_set_is_client(bool value);

  public:
  // @@protoc_insertion_point(class_scope:RouteMsgStringRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::RouteNodeInfo > route_data_list_;
    ::google::protobuf::internal::ArenaStringPtr body_;
    ::uint64_t session_id_;
    ::uint64_t id_;
    bool is_client_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fcommon_5fmessage_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RouteNodeInfo

// .NodeInfo node_info = 1;
inline bool RouteNodeInfo::has_node_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.node_info_ != nullptr);
  return value;
}
inline const ::NodeInfo& RouteNodeInfo::_internal_node_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NodeInfo* p = _impl_.node_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::NodeInfo&>(::_NodeInfo_default_instance_);
}
inline const ::NodeInfo& RouteNodeInfo::node_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RouteNodeInfo.node_info)
  return _internal_node_info();
}
inline void RouteNodeInfo::unsafe_arena_set_allocated_node_info(::NodeInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_info_);
  }
  _impl_.node_info_ = reinterpret_cast<::NodeInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RouteNodeInfo.node_info)
}
inline ::NodeInfo* RouteNodeInfo::release_node_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NodeInfo* released = _impl_.node_info_;
  _impl_.node_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NodeInfo* RouteNodeInfo::unsafe_arena_release_node_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RouteNodeInfo.node_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NodeInfo* temp = _impl_.node_info_;
  _impl_.node_info_ = nullptr;
  return temp;
}
inline ::NodeInfo* RouteNodeInfo::_internal_mutable_node_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.node_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NodeInfo>(GetArena());
    _impl_.node_info_ = reinterpret_cast<::NodeInfo*>(p);
  }
  return _impl_.node_info_;
}
inline ::NodeInfo* RouteNodeInfo::mutable_node_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::NodeInfo* _msg = _internal_mutable_node_info();
  // @@protoc_insertion_point(field_mutable:RouteNodeInfo.node_info)
  return _msg;
}
inline void RouteNodeInfo::set_allocated_node_info(::NodeInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.node_info_ = reinterpret_cast<::NodeInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:RouteNodeInfo.node_info)
}

// uint32 message_id = 2;
inline void RouteNodeInfo::clear_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_id_ = 0u;
}
inline ::uint32_t RouteNodeInfo::message_id() const {
  // @@protoc_insertion_point(field_get:RouteNodeInfo.message_id)
  return _internal_message_id();
}
inline void RouteNodeInfo::set_message_id(::uint32_t value) {
  _internal_set_message_id(value);
  // @@protoc_insertion_point(field_set:RouteNodeInfo.message_id)
}
inline ::uint32_t RouteNodeInfo::_internal_message_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_id_;
}
inline void RouteNodeInfo::_internal_set_message_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_id_ = value;
}

// -------------------------------------------------------------------

// MessageBody

// bytes body = 1;
inline void MessageBody::clear_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.ClearToEmpty();
}
inline const std::string& MessageBody::body() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MessageBody.body)
  return _internal_body();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageBody::set_body(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MessageBody.body)
}
inline std::string* MessageBody::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:MessageBody.body)
  return _s;
}
inline const std::string& MessageBody::_internal_body() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.body_.Get();
}
inline void MessageBody::_internal_set_body(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.Set(value, GetArena());
}
inline std::string* MessageBody::_internal_mutable_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.body_.Mutable( GetArena());
}
inline std::string* MessageBody::release_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MessageBody.body)
  return _impl_.body_.Release();
}
inline void MessageBody::set_allocated_body(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.body_.IsDefault()) {
          _impl_.body_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MessageBody.body)
}

// uint32 message_id = 2;
inline void MessageBody::clear_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_id_ = 0u;
}
inline ::uint32_t MessageBody::message_id() const {
  // @@protoc_insertion_point(field_get:MessageBody.message_id)
  return _internal_message_id();
}
inline void MessageBody::set_message_id(::uint32_t value) {
  _internal_set_message_id(value);
  // @@protoc_insertion_point(field_set:MessageBody.message_id)
}
inline ::uint32_t MessageBody::_internal_message_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_id_;
}
inline void MessageBody::_internal_set_message_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_id_ = value;
}

// uint64 id = 3;
inline void MessageBody::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t MessageBody::id() const {
  // @@protoc_insertion_point(field_get:MessageBody.id)
  return _internal_id();
}
inline void MessageBody::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:MessageBody.id)
}
inline ::uint64_t MessageBody::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void MessageBody::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// NodeMessageHead

// uint32 node_id = 1;
inline void NodeMessageHead::clear_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_id_ = 0u;
}
inline ::uint32_t NodeMessageHead::node_id() const {
  // @@protoc_insertion_point(field_get:NodeMessageHead.node_id)
  return _internal_node_id();
}
inline void NodeMessageHead::set_node_id(::uint32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:NodeMessageHead.node_id)
}
inline ::uint32_t NodeMessageHead::_internal_node_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_id_;
}
inline void NodeMessageHead::_internal_set_node_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_id_ = value;
}

// uint64 session_id = 2;
inline void NodeMessageHead::clear_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_ = ::uint64_t{0u};
}
inline ::uint64_t NodeMessageHead::session_id() const {
  // @@protoc_insertion_point(field_get:NodeMessageHead.session_id)
  return _internal_session_id();
}
inline void NodeMessageHead::set_session_id(::uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:NodeMessageHead.session_id)
}
inline ::uint64_t NodeMessageHead::_internal_session_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.session_id_;
}
inline void NodeMessageHead::_internal_set_session_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_ = value;
}

// -------------------------------------------------------------------

// NodeRouteMessageRequest

// .MessageBody body = 1;
inline bool NodeRouteMessageRequest::has_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.body_ != nullptr);
  return value;
}
inline void NodeRouteMessageRequest::clear_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.body_ != nullptr) _impl_.body_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MessageBody& NodeRouteMessageRequest::_internal_body() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::MessageBody* p = _impl_.body_;
  return p != nullptr ? *p : reinterpret_cast<const ::MessageBody&>(::_MessageBody_default_instance_);
}
inline const ::MessageBody& NodeRouteMessageRequest::body() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NodeRouteMessageRequest.body)
  return _internal_body();
}
inline void NodeRouteMessageRequest::unsafe_arena_set_allocated_body(::MessageBody* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.body_);
  }
  _impl_.body_ = reinterpret_cast<::MessageBody*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NodeRouteMessageRequest.body)
}
inline ::MessageBody* NodeRouteMessageRequest::release_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MessageBody* released = _impl_.body_;
  _impl_.body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::MessageBody* NodeRouteMessageRequest::unsafe_arena_release_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NodeRouteMessageRequest.body)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MessageBody* temp = _impl_.body_;
  _impl_.body_ = nullptr;
  return temp;
}
inline ::MessageBody* NodeRouteMessageRequest::_internal_mutable_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.body_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::MessageBody>(GetArena());
    _impl_.body_ = reinterpret_cast<::MessageBody*>(p);
  }
  return _impl_.body_;
}
inline ::MessageBody* NodeRouteMessageRequest::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::MessageBody* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:NodeRouteMessageRequest.body)
  return _msg;
}
inline void NodeRouteMessageRequest::set_allocated_body(::MessageBody* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.body_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.body_ = reinterpret_cast<::MessageBody*>(value);
  // @@protoc_insertion_point(field_set_allocated:NodeRouteMessageRequest.body)
}

// .NodeMessageHead head = 2;
inline bool NodeRouteMessageRequest::has_head() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.head_ != nullptr);
  return value;
}
inline void NodeRouteMessageRequest::clear_head() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.head_ != nullptr) _impl_.head_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::NodeMessageHead& NodeRouteMessageRequest::_internal_head() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NodeMessageHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::NodeMessageHead&>(::_NodeMessageHead_default_instance_);
}
inline const ::NodeMessageHead& NodeRouteMessageRequest::head() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NodeRouteMessageRequest.head)
  return _internal_head();
}
inline void NodeRouteMessageRequest::unsafe_arena_set_allocated_head(::NodeMessageHead* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = reinterpret_cast<::NodeMessageHead*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NodeRouteMessageRequest.head)
}
inline ::NodeMessageHead* NodeRouteMessageRequest::release_head() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NodeMessageHead* released = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NodeMessageHead* NodeRouteMessageRequest::unsafe_arena_release_head() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NodeRouteMessageRequest.head)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NodeMessageHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::NodeMessageHead* NodeRouteMessageRequest::_internal_mutable_head() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.head_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NodeMessageHead>(GetArena());
    _impl_.head_ = reinterpret_cast<::NodeMessageHead*>(p);
  }
  return _impl_.head_;
}
inline ::NodeMessageHead* NodeRouteMessageRequest::mutable_head() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::NodeMessageHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:NodeRouteMessageRequest.head)
  return _msg;
}
inline void NodeRouteMessageRequest::set_allocated_head(::NodeMessageHead* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.head_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.head_ = reinterpret_cast<::NodeMessageHead*>(value);
  // @@protoc_insertion_point(field_set_allocated:NodeRouteMessageRequest.head)
}

// -------------------------------------------------------------------

// NodeRouteMessageResponse

// .MessageBody body = 1;
inline bool NodeRouteMessageResponse::has_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.body_ != nullptr);
  return value;
}
inline void NodeRouteMessageResponse::clear_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.body_ != nullptr) _impl_.body_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MessageBody& NodeRouteMessageResponse::_internal_body() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::MessageBody* p = _impl_.body_;
  return p != nullptr ? *p : reinterpret_cast<const ::MessageBody&>(::_MessageBody_default_instance_);
}
inline const ::MessageBody& NodeRouteMessageResponse::body() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NodeRouteMessageResponse.body)
  return _internal_body();
}
inline void NodeRouteMessageResponse::unsafe_arena_set_allocated_body(::MessageBody* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.body_);
  }
  _impl_.body_ = reinterpret_cast<::MessageBody*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NodeRouteMessageResponse.body)
}
inline ::MessageBody* NodeRouteMessageResponse::release_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MessageBody* released = _impl_.body_;
  _impl_.body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::MessageBody* NodeRouteMessageResponse::unsafe_arena_release_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NodeRouteMessageResponse.body)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MessageBody* temp = _impl_.body_;
  _impl_.body_ = nullptr;
  return temp;
}
inline ::MessageBody* NodeRouteMessageResponse::_internal_mutable_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.body_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::MessageBody>(GetArena());
    _impl_.body_ = reinterpret_cast<::MessageBody*>(p);
  }
  return _impl_.body_;
}
inline ::MessageBody* NodeRouteMessageResponse::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::MessageBody* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:NodeRouteMessageResponse.body)
  return _msg;
}
inline void NodeRouteMessageResponse::set_allocated_body(::MessageBody* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.body_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.body_ = reinterpret_cast<::MessageBody*>(value);
  // @@protoc_insertion_point(field_set_allocated:NodeRouteMessageResponse.body)
}

// .NodeMessageHead head = 2;
inline bool NodeRouteMessageResponse::has_head() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.head_ != nullptr);
  return value;
}
inline void NodeRouteMessageResponse::clear_head() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.head_ != nullptr) _impl_.head_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::NodeMessageHead& NodeRouteMessageResponse::_internal_head() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NodeMessageHead* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::NodeMessageHead&>(::_NodeMessageHead_default_instance_);
}
inline const ::NodeMessageHead& NodeRouteMessageResponse::head() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NodeRouteMessageResponse.head)
  return _internal_head();
}
inline void NodeRouteMessageResponse::unsafe_arena_set_allocated_head(::NodeMessageHead* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = reinterpret_cast<::NodeMessageHead*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NodeRouteMessageResponse.head)
}
inline ::NodeMessageHead* NodeRouteMessageResponse::release_head() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NodeMessageHead* released = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NodeMessageHead* NodeRouteMessageResponse::unsafe_arena_release_head() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NodeRouteMessageResponse.head)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NodeMessageHead* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::NodeMessageHead* NodeRouteMessageResponse::_internal_mutable_head() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.head_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NodeMessageHead>(GetArena());
    _impl_.head_ = reinterpret_cast<::NodeMessageHead*>(p);
  }
  return _impl_.head_;
}
inline ::NodeMessageHead* NodeRouteMessageResponse::mutable_head() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::NodeMessageHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:NodeRouteMessageResponse.head)
  return _msg;
}
inline void NodeRouteMessageResponse::set_allocated_head(::NodeMessageHead* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.head_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.head_ = reinterpret_cast<::NodeMessageHead*>(value);
  // @@protoc_insertion_point(field_set_allocated:NodeRouteMessageResponse.head)
}

// -------------------------------------------------------------------

// PlayerMessageExtern

// uint64 player_id = 1;
inline void PlayerMessageExtern::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerMessageExtern::player_id() const {
  // @@protoc_insertion_point(field_get:PlayerMessageExtern.player_id)
  return _internal_player_id();
}
inline void PlayerMessageExtern::set_player_id(::uint64_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:PlayerMessageExtern.player_id)
}
inline ::uint64_t PlayerMessageExtern::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_;
}
inline void PlayerMessageExtern::_internal_set_player_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_ = value;
}

// -------------------------------------------------------------------

// PlayerNodeServiceRequest

// .MessageBody body = 1;
inline bool PlayerNodeServiceRequest::has_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.body_ != nullptr);
  return value;
}
inline void PlayerNodeServiceRequest::clear_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.body_ != nullptr) _impl_.body_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MessageBody& PlayerNodeServiceRequest::_internal_body() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::MessageBody* p = _impl_.body_;
  return p != nullptr ? *p : reinterpret_cast<const ::MessageBody&>(::_MessageBody_default_instance_);
}
inline const ::MessageBody& PlayerNodeServiceRequest::body() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PlayerNodeServiceRequest.body)
  return _internal_body();
}
inline void PlayerNodeServiceRequest::unsafe_arena_set_allocated_body(::MessageBody* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.body_);
  }
  _impl_.body_ = reinterpret_cast<::MessageBody*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerNodeServiceRequest.body)
}
inline ::MessageBody* PlayerNodeServiceRequest::release_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MessageBody* released = _impl_.body_;
  _impl_.body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::MessageBody* PlayerNodeServiceRequest::unsafe_arena_release_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:PlayerNodeServiceRequest.body)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MessageBody* temp = _impl_.body_;
  _impl_.body_ = nullptr;
  return temp;
}
inline ::MessageBody* PlayerNodeServiceRequest::_internal_mutable_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.body_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::MessageBody>(GetArena());
    _impl_.body_ = reinterpret_cast<::MessageBody*>(p);
  }
  return _impl_.body_;
}
inline ::MessageBody* PlayerNodeServiceRequest::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::MessageBody* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:PlayerNodeServiceRequest.body)
  return _msg;
}
inline void PlayerNodeServiceRequest::set_allocated_body(::MessageBody* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.body_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.body_ = reinterpret_cast<::MessageBody*>(value);
  // @@protoc_insertion_point(field_set_allocated:PlayerNodeServiceRequest.body)
}

// .PlayerMessageExtern head = 2;
inline bool PlayerNodeServiceRequest::has_head() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.head_ != nullptr);
  return value;
}
inline void PlayerNodeServiceRequest::clear_head() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.head_ != nullptr) _impl_.head_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::PlayerMessageExtern& PlayerNodeServiceRequest::_internal_head() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::PlayerMessageExtern* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerMessageExtern&>(::_PlayerMessageExtern_default_instance_);
}
inline const ::PlayerMessageExtern& PlayerNodeServiceRequest::head() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PlayerNodeServiceRequest.head)
  return _internal_head();
}
inline void PlayerNodeServiceRequest::unsafe_arena_set_allocated_head(::PlayerMessageExtern* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = reinterpret_cast<::PlayerMessageExtern*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerNodeServiceRequest.head)
}
inline ::PlayerMessageExtern* PlayerNodeServiceRequest::release_head() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PlayerMessageExtern* released = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::PlayerMessageExtern* PlayerNodeServiceRequest::unsafe_arena_release_head() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:PlayerNodeServiceRequest.head)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PlayerMessageExtern* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::PlayerMessageExtern* PlayerNodeServiceRequest::_internal_mutable_head() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.head_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::PlayerMessageExtern>(GetArena());
    _impl_.head_ = reinterpret_cast<::PlayerMessageExtern*>(p);
  }
  return _impl_.head_;
}
inline ::PlayerMessageExtern* PlayerNodeServiceRequest::mutable_head() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::PlayerMessageExtern* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:PlayerNodeServiceRequest.head)
  return _msg;
}
inline void PlayerNodeServiceRequest::set_allocated_head(::PlayerMessageExtern* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.head_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.head_ = reinterpret_cast<::PlayerMessageExtern*>(value);
  // @@protoc_insertion_point(field_set_allocated:PlayerNodeServiceRequest.head)
}

// -------------------------------------------------------------------

// PlayerMessageResponse

// .MessageBody body = 1;
inline bool PlayerMessageResponse::has_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.body_ != nullptr);
  return value;
}
inline void PlayerMessageResponse::clear_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.body_ != nullptr) _impl_.body_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MessageBody& PlayerMessageResponse::_internal_body() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::MessageBody* p = _impl_.body_;
  return p != nullptr ? *p : reinterpret_cast<const ::MessageBody&>(::_MessageBody_default_instance_);
}
inline const ::MessageBody& PlayerMessageResponse::body() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PlayerMessageResponse.body)
  return _internal_body();
}
inline void PlayerMessageResponse::unsafe_arena_set_allocated_body(::MessageBody* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.body_);
  }
  _impl_.body_ = reinterpret_cast<::MessageBody*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerMessageResponse.body)
}
inline ::MessageBody* PlayerMessageResponse::release_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MessageBody* released = _impl_.body_;
  _impl_.body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::MessageBody* PlayerMessageResponse::unsafe_arena_release_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:PlayerMessageResponse.body)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MessageBody* temp = _impl_.body_;
  _impl_.body_ = nullptr;
  return temp;
}
inline ::MessageBody* PlayerMessageResponse::_internal_mutable_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.body_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::MessageBody>(GetArena());
    _impl_.body_ = reinterpret_cast<::MessageBody*>(p);
  }
  return _impl_.body_;
}
inline ::MessageBody* PlayerMessageResponse::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::MessageBody* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:PlayerMessageResponse.body)
  return _msg;
}
inline void PlayerMessageResponse::set_allocated_body(::MessageBody* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.body_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.body_ = reinterpret_cast<::MessageBody*>(value);
  // @@protoc_insertion_point(field_set_allocated:PlayerMessageResponse.body)
}

// .PlayerMessageExtern head = 2;
inline bool PlayerMessageResponse::has_head() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.head_ != nullptr);
  return value;
}
inline void PlayerMessageResponse::clear_head() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.head_ != nullptr) _impl_.head_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::PlayerMessageExtern& PlayerMessageResponse::_internal_head() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::PlayerMessageExtern* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerMessageExtern&>(::_PlayerMessageExtern_default_instance_);
}
inline const ::PlayerMessageExtern& PlayerMessageResponse::head() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PlayerMessageResponse.head)
  return _internal_head();
}
inline void PlayerMessageResponse::unsafe_arena_set_allocated_head(::PlayerMessageExtern* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = reinterpret_cast<::PlayerMessageExtern*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerMessageResponse.head)
}
inline ::PlayerMessageExtern* PlayerMessageResponse::release_head() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PlayerMessageExtern* released = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::PlayerMessageExtern* PlayerMessageResponse::unsafe_arena_release_head() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:PlayerMessageResponse.head)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PlayerMessageExtern* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::PlayerMessageExtern* PlayerMessageResponse::_internal_mutable_head() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.head_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::PlayerMessageExtern>(GetArena());
    _impl_.head_ = reinterpret_cast<::PlayerMessageExtern*>(p);
  }
  return _impl_.head_;
}
inline ::PlayerMessageExtern* PlayerMessageResponse::mutable_head() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::PlayerMessageExtern* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:PlayerMessageResponse.head)
  return _msg;
}
inline void PlayerMessageResponse::set_allocated_head(::PlayerMessageExtern* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.head_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.head_ = reinterpret_cast<::PlayerMessageExtern*>(value);
  // @@protoc_insertion_point(field_set_allocated:PlayerMessageResponse.head)
}

// -------------------------------------------------------------------

// NodeRouteMessageBody

// .NodeInfo node_info = 2;
inline bool NodeRouteMessageBody::has_node_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.node_info_ != nullptr);
  return value;
}
inline const ::NodeInfo& NodeRouteMessageBody::_internal_node_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NodeInfo* p = _impl_.node_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::NodeInfo&>(::_NodeInfo_default_instance_);
}
inline const ::NodeInfo& NodeRouteMessageBody::node_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NodeRouteMessageBody.node_info)
  return _internal_node_info();
}
inline void NodeRouteMessageBody::unsafe_arena_set_allocated_node_info(::NodeInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_info_);
  }
  _impl_.node_info_ = reinterpret_cast<::NodeInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NodeRouteMessageBody.node_info)
}
inline ::NodeInfo* NodeRouteMessageBody::release_node_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NodeInfo* released = _impl_.node_info_;
  _impl_.node_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NodeInfo* NodeRouteMessageBody::unsafe_arena_release_node_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NodeRouteMessageBody.node_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NodeInfo* temp = _impl_.node_info_;
  _impl_.node_info_ = nullptr;
  return temp;
}
inline ::NodeInfo* NodeRouteMessageBody::_internal_mutable_node_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.node_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NodeInfo>(GetArena());
    _impl_.node_info_ = reinterpret_cast<::NodeInfo*>(p);
  }
  return _impl_.node_info_;
}
inline ::NodeInfo* NodeRouteMessageBody::mutable_node_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::NodeInfo* _msg = _internal_mutable_node_info();
  // @@protoc_insertion_point(field_mutable:NodeRouteMessageBody.node_info)
  return _msg;
}
inline void NodeRouteMessageBody::set_allocated_node_info(::NodeInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.node_info_ = reinterpret_cast<::NodeInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:NodeRouteMessageBody.node_info)
}

// -------------------------------------------------------------------

// RegisterGameNodeSessionRequest

// .SessionDetails session_info = 1;
inline bool RegisterGameNodeSessionRequest::has_session_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.session_info_ != nullptr);
  return value;
}
inline const ::SessionDetails& RegisterGameNodeSessionRequest::_internal_session_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SessionDetails* p = _impl_.session_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionDetails&>(::_SessionDetails_default_instance_);
}
inline const ::SessionDetails& RegisterGameNodeSessionRequest::session_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterGameNodeSessionRequest.session_info)
  return _internal_session_info();
}
inline void RegisterGameNodeSessionRequest::unsafe_arena_set_allocated_session_info(::SessionDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }
  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterGameNodeSessionRequest.session_info)
}
inline ::SessionDetails* RegisterGameNodeSessionRequest::release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* released = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SessionDetails* RegisterGameNodeSessionRequest::unsafe_arena_release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RegisterGameNodeSessionRequest.session_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* temp = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
  return temp;
}
inline ::SessionDetails* RegisterGameNodeSessionRequest::_internal_mutable_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.session_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::SessionDetails>(GetArena());
    _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(p);
  }
  return _impl_.session_info_;
}
inline ::SessionDetails* RegisterGameNodeSessionRequest::mutable_session_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::SessionDetails* _msg = _internal_mutable_session_info();
  // @@protoc_insertion_point(field_mutable:RegisterGameNodeSessionRequest.session_info)
  return _msg;
}
inline void RegisterGameNodeSessionRequest::set_allocated_session_info(::SessionDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:RegisterGameNodeSessionRequest.session_info)
}

// uint32 game_node_id = 2;
inline void RegisterGameNodeSessionRequest::clear_game_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_node_id_ = 0u;
}
inline ::uint32_t RegisterGameNodeSessionRequest::game_node_id() const {
  // @@protoc_insertion_point(field_get:RegisterGameNodeSessionRequest.game_node_id)
  return _internal_game_node_id();
}
inline void RegisterGameNodeSessionRequest::set_game_node_id(::uint32_t value) {
  _internal_set_game_node_id(value);
  // @@protoc_insertion_point(field_set:RegisterGameNodeSessionRequest.game_node_id)
}
inline ::uint32_t RegisterGameNodeSessionRequest::_internal_game_node_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.game_node_id_;
}
inline void RegisterGameNodeSessionRequest::_internal_set_game_node_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_node_id_ = value;
}

// -------------------------------------------------------------------

// RegisterGameNodeSessionResponse

// .SessionDetails session_info = 1;
inline bool RegisterGameNodeSessionResponse::has_session_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.session_info_ != nullptr);
  return value;
}
inline const ::SessionDetails& RegisterGameNodeSessionResponse::_internal_session_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SessionDetails* p = _impl_.session_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionDetails&>(::_SessionDetails_default_instance_);
}
inline const ::SessionDetails& RegisterGameNodeSessionResponse::session_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterGameNodeSessionResponse.session_info)
  return _internal_session_info();
}
inline void RegisterGameNodeSessionResponse::unsafe_arena_set_allocated_session_info(::SessionDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }
  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterGameNodeSessionResponse.session_info)
}
inline ::SessionDetails* RegisterGameNodeSessionResponse::release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* released = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SessionDetails* RegisterGameNodeSessionResponse::unsafe_arena_release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RegisterGameNodeSessionResponse.session_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* temp = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
  return temp;
}
inline ::SessionDetails* RegisterGameNodeSessionResponse::_internal_mutable_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.session_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::SessionDetails>(GetArena());
    _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(p);
  }
  return _impl_.session_info_;
}
inline ::SessionDetails* RegisterGameNodeSessionResponse::mutable_session_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::SessionDetails* _msg = _internal_mutable_session_info();
  // @@protoc_insertion_point(field_mutable:RegisterGameNodeSessionResponse.session_info)
  return _msg;
}
inline void RegisterGameNodeSessionResponse::set_allocated_session_info(::SessionDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:RegisterGameNodeSessionResponse.session_info)
}

// -------------------------------------------------------------------

// RegisterSessionGateNodeResponse

// .SessionDetails session_info = 1;
inline bool RegisterSessionGateNodeResponse::has_session_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.session_info_ != nullptr);
  return value;
}
inline const ::SessionDetails& RegisterSessionGateNodeResponse::_internal_session_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SessionDetails* p = _impl_.session_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionDetails&>(::_SessionDetails_default_instance_);
}
inline const ::SessionDetails& RegisterSessionGateNodeResponse::session_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterSessionGateNodeResponse.session_info)
  return _internal_session_info();
}
inline void RegisterSessionGateNodeResponse::unsafe_arena_set_allocated_session_info(::SessionDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }
  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterSessionGateNodeResponse.session_info)
}
inline ::SessionDetails* RegisterSessionGateNodeResponse::release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* released = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SessionDetails* RegisterSessionGateNodeResponse::unsafe_arena_release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RegisterSessionGateNodeResponse.session_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* temp = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
  return temp;
}
inline ::SessionDetails* RegisterSessionGateNodeResponse::_internal_mutable_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.session_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::SessionDetails>(GetArena());
    _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(p);
  }
  return _impl_.session_info_;
}
inline ::SessionDetails* RegisterSessionGateNodeResponse::mutable_session_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::SessionDetails* _msg = _internal_mutable_session_info();
  // @@protoc_insertion_point(field_mutable:RegisterSessionGateNodeResponse.session_info)
  return _msg;
}
inline void RegisterSessionGateNodeResponse::set_allocated_session_info(::SessionDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:RegisterSessionGateNodeResponse.session_info)
}

// -------------------------------------------------------------------

// RegisterCentreSessionNodeRequest

// .SessionDetails session_info = 1;
inline bool RegisterCentreSessionNodeRequest::has_session_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.session_info_ != nullptr);
  return value;
}
inline const ::SessionDetails& RegisterCentreSessionNodeRequest::_internal_session_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SessionDetails* p = _impl_.session_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionDetails&>(::_SessionDetails_default_instance_);
}
inline const ::SessionDetails& RegisterCentreSessionNodeRequest::session_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterCentreSessionNodeRequest.session_info)
  return _internal_session_info();
}
inline void RegisterCentreSessionNodeRequest::unsafe_arena_set_allocated_session_info(::SessionDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }
  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterCentreSessionNodeRequest.session_info)
}
inline ::SessionDetails* RegisterCentreSessionNodeRequest::release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* released = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SessionDetails* RegisterCentreSessionNodeRequest::unsafe_arena_release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RegisterCentreSessionNodeRequest.session_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* temp = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
  return temp;
}
inline ::SessionDetails* RegisterCentreSessionNodeRequest::_internal_mutable_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.session_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::SessionDetails>(GetArena());
    _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(p);
  }
  return _impl_.session_info_;
}
inline ::SessionDetails* RegisterCentreSessionNodeRequest::mutable_session_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::SessionDetails* _msg = _internal_mutable_session_info();
  // @@protoc_insertion_point(field_mutable:RegisterCentreSessionNodeRequest.session_info)
  return _msg;
}
inline void RegisterCentreSessionNodeRequest::set_allocated_session_info(::SessionDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:RegisterCentreSessionNodeRequest.session_info)
}

// uint32 centre_node_id = 2;
inline void RegisterCentreSessionNodeRequest::clear_centre_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.centre_node_id_ = 0u;
}
inline ::uint32_t RegisterCentreSessionNodeRequest::centre_node_id() const {
  // @@protoc_insertion_point(field_get:RegisterCentreSessionNodeRequest.centre_node_id)
  return _internal_centre_node_id();
}
inline void RegisterCentreSessionNodeRequest::set_centre_node_id(::uint32_t value) {
  _internal_set_centre_node_id(value);
  // @@protoc_insertion_point(field_set:RegisterCentreSessionNodeRequest.centre_node_id)
}
inline ::uint32_t RegisterCentreSessionNodeRequest::_internal_centre_node_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.centre_node_id_;
}
inline void RegisterCentreSessionNodeRequest::_internal_set_centre_node_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.centre_node_id_ = value;
}

// -------------------------------------------------------------------

// RegisterSessionCentreNodeResponse

// .SessionDetails session_info = 1;
inline bool RegisterSessionCentreNodeResponse::has_session_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.session_info_ != nullptr);
  return value;
}
inline const ::SessionDetails& RegisterSessionCentreNodeResponse::_internal_session_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SessionDetails* p = _impl_.session_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionDetails&>(::_SessionDetails_default_instance_);
}
inline const ::SessionDetails& RegisterSessionCentreNodeResponse::session_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterSessionCentreNodeResponse.session_info)
  return _internal_session_info();
}
inline void RegisterSessionCentreNodeResponse::unsafe_arena_set_allocated_session_info(::SessionDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }
  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterSessionCentreNodeResponse.session_info)
}
inline ::SessionDetails* RegisterSessionCentreNodeResponse::release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* released = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SessionDetails* RegisterSessionCentreNodeResponse::unsafe_arena_release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RegisterSessionCentreNodeResponse.session_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* temp = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
  return temp;
}
inline ::SessionDetails* RegisterSessionCentreNodeResponse::_internal_mutable_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.session_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::SessionDetails>(GetArena());
    _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(p);
  }
  return _impl_.session_info_;
}
inline ::SessionDetails* RegisterSessionCentreNodeResponse::mutable_session_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::SessionDetails* _msg = _internal_mutable_session_info();
  // @@protoc_insertion_point(field_mutable:RegisterSessionCentreNodeResponse.session_info)
  return _msg;
}
inline void RegisterSessionCentreNodeResponse::set_allocated_session_info(::SessionDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:RegisterSessionCentreNodeResponse.session_info)
}

// -------------------------------------------------------------------

// GateSessionDisconnectRequest

// .SessionDetails session_info = 1;
inline bool GateSessionDisconnectRequest::has_session_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.session_info_ != nullptr);
  return value;
}
inline const ::SessionDetails& GateSessionDisconnectRequest::_internal_session_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SessionDetails* p = _impl_.session_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionDetails&>(::_SessionDetails_default_instance_);
}
inline const ::SessionDetails& GateSessionDisconnectRequest::session_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GateSessionDisconnectRequest.session_info)
  return _internal_session_info();
}
inline void GateSessionDisconnectRequest::unsafe_arena_set_allocated_session_info(::SessionDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }
  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GateSessionDisconnectRequest.session_info)
}
inline ::SessionDetails* GateSessionDisconnectRequest::release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* released = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SessionDetails* GateSessionDisconnectRequest::unsafe_arena_release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GateSessionDisconnectRequest.session_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* temp = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
  return temp;
}
inline ::SessionDetails* GateSessionDisconnectRequest::_internal_mutable_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.session_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::SessionDetails>(GetArena());
    _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(p);
  }
  return _impl_.session_info_;
}
inline ::SessionDetails* GateSessionDisconnectRequest::mutable_session_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::SessionDetails* _msg = _internal_mutable_session_info();
  // @@protoc_insertion_point(field_mutable:GateSessionDisconnectRequest.session_info)
  return _msg;
}
inline void GateSessionDisconnectRequest::set_allocated_session_info(::SessionDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:GateSessionDisconnectRequest.session_info)
}

// -------------------------------------------------------------------

// RouteMsgStringRequest

// bytes body = 1;
inline void RouteMsgStringRequest::clear_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.ClearToEmpty();
}
inline const std::string& RouteMsgStringRequest::body() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RouteMsgStringRequest.body)
  return _internal_body();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouteMsgStringRequest::set_body(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RouteMsgStringRequest.body)
}
inline std::string* RouteMsgStringRequest::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:RouteMsgStringRequest.body)
  return _s;
}
inline const std::string& RouteMsgStringRequest::_internal_body() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.body_.Get();
}
inline void RouteMsgStringRequest::_internal_set_body(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.Set(value, GetArena());
}
inline std::string* RouteMsgStringRequest::_internal_mutable_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.body_.Mutable( GetArena());
}
inline std::string* RouteMsgStringRequest::release_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RouteMsgStringRequest.body)
  return _impl_.body_.Release();
}
inline void RouteMsgStringRequest::set_allocated_body(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.body_.IsDefault()) {
          _impl_.body_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RouteMsgStringRequest.body)
}

// repeated .RouteNodeInfo route_data_list = 2;
inline int RouteMsgStringRequest::_internal_route_data_list_size() const {
  return _internal_route_data_list().size();
}
inline int RouteMsgStringRequest::route_data_list_size() const {
  return _internal_route_data_list_size();
}
inline void RouteMsgStringRequest::clear_route_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.route_data_list_.Clear();
}
inline ::RouteNodeInfo* RouteMsgStringRequest::mutable_route_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:RouteMsgStringRequest.route_data_list)
  return _internal_mutable_route_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::RouteNodeInfo>* RouteMsgStringRequest::mutable_route_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:RouteMsgStringRequest.route_data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_route_data_list();
}
inline const ::RouteNodeInfo& RouteMsgStringRequest::route_data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RouteMsgStringRequest.route_data_list)
  return _internal_route_data_list().Get(index);
}
inline ::RouteNodeInfo* RouteMsgStringRequest::add_route_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::RouteNodeInfo* _add = _internal_mutable_route_data_list()->Add();
  // @@protoc_insertion_point(field_add:RouteMsgStringRequest.route_data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::RouteNodeInfo>& RouteMsgStringRequest::route_data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:RouteMsgStringRequest.route_data_list)
  return _internal_route_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::RouteNodeInfo>&
RouteMsgStringRequest::_internal_route_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.route_data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::RouteNodeInfo>*
RouteMsgStringRequest::_internal_mutable_route_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.route_data_list_;
}

// uint64 session_id = 3;
inline void RouteMsgStringRequest::clear_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_ = ::uint64_t{0u};
}
inline ::uint64_t RouteMsgStringRequest::session_id() const {
  // @@protoc_insertion_point(field_get:RouteMsgStringRequest.session_id)
  return _internal_session_id();
}
inline void RouteMsgStringRequest::set_session_id(::uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:RouteMsgStringRequest.session_id)
}
inline ::uint64_t RouteMsgStringRequest::_internal_session_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.session_id_;
}
inline void RouteMsgStringRequest::_internal_set_session_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_ = value;
}

// uint64 id = 4;
inline void RouteMsgStringRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t RouteMsgStringRequest::id() const {
  // @@protoc_insertion_point(field_get:RouteMsgStringRequest.id)
  return _internal_id();
}
inline void RouteMsgStringRequest::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:RouteMsgStringRequest.id)
}
inline ::uint64_t RouteMsgStringRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void RouteMsgStringRequest::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = value;
}

// bool is_client = 5;
inline void RouteMsgStringRequest::clear_is_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_client_ = false;
}
inline bool RouteMsgStringRequest::is_client() const {
  // @@protoc_insertion_point(field_get:RouteMsgStringRequest.is_client)
  return _internal_is_client();
}
inline void RouteMsgStringRequest::set_is_client(bool value) {
  _internal_set_is_client(value);
  // @@protoc_insertion_point(field_set:RouteMsgStringRequest.is_client)
}
inline bool RouteMsgStringRequest::_internal_is_client() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_client_;
}
inline void RouteMsgStringRequest::_internal_set_is_client(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_client_ = value;
}

// -------------------------------------------------------------------

// RouteMsgStringResponse

// bytes body = 1;
inline void RouteMsgStringResponse::clear_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.ClearToEmpty();
}
inline const std::string& RouteMsgStringResponse::body() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RouteMsgStringResponse.body)
  return _internal_body();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouteMsgStringResponse::set_body(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RouteMsgStringResponse.body)
}
inline std::string* RouteMsgStringResponse::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:RouteMsgStringResponse.body)
  return _s;
}
inline const std::string& RouteMsgStringResponse::_internal_body() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.body_.Get();
}
inline void RouteMsgStringResponse::_internal_set_body(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.Set(value, GetArena());
}
inline std::string* RouteMsgStringResponse::_internal_mutable_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.body_.Mutable( GetArena());
}
inline std::string* RouteMsgStringResponse::release_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RouteMsgStringResponse.body)
  return _impl_.body_.Release();
}
inline void RouteMsgStringResponse::set_allocated_body(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.body_.IsDefault()) {
          _impl_.body_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RouteMsgStringResponse.body)
}

// repeated .RouteNodeInfo route_data_list = 2;
inline int RouteMsgStringResponse::_internal_route_data_list_size() const {
  return _internal_route_data_list().size();
}
inline int RouteMsgStringResponse::route_data_list_size() const {
  return _internal_route_data_list_size();
}
inline void RouteMsgStringResponse::clear_route_data_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.route_data_list_.Clear();
}
inline ::RouteNodeInfo* RouteMsgStringResponse::mutable_route_data_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:RouteMsgStringResponse.route_data_list)
  return _internal_mutable_route_data_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::RouteNodeInfo>* RouteMsgStringResponse::mutable_route_data_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:RouteMsgStringResponse.route_data_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_route_data_list();
}
inline const ::RouteNodeInfo& RouteMsgStringResponse::route_data_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RouteMsgStringResponse.route_data_list)
  return _internal_route_data_list().Get(index);
}
inline ::RouteNodeInfo* RouteMsgStringResponse::add_route_data_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::RouteNodeInfo* _add = _internal_mutable_route_data_list()->Add();
  // @@protoc_insertion_point(field_add:RouteMsgStringResponse.route_data_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::RouteNodeInfo>& RouteMsgStringResponse::route_data_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:RouteMsgStringResponse.route_data_list)
  return _internal_route_data_list();
}
inline const ::google::protobuf::RepeatedPtrField<::RouteNodeInfo>&
RouteMsgStringResponse::_internal_route_data_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.route_data_list_;
}
inline ::google::protobuf::RepeatedPtrField<::RouteNodeInfo>*
RouteMsgStringResponse::_internal_mutable_route_data_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.route_data_list_;
}

// uint64 session_id = 3;
inline void RouteMsgStringResponse::clear_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_ = ::uint64_t{0u};
}
inline ::uint64_t RouteMsgStringResponse::session_id() const {
  // @@protoc_insertion_point(field_get:RouteMsgStringResponse.session_id)
  return _internal_session_id();
}
inline void RouteMsgStringResponse::set_session_id(::uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:RouteMsgStringResponse.session_id)
}
inline ::uint64_t RouteMsgStringResponse::_internal_session_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.session_id_;
}
inline void RouteMsgStringResponse::_internal_set_session_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_ = value;
}

// uint64 id = 4;
inline void RouteMsgStringResponse::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t RouteMsgStringResponse::id() const {
  // @@protoc_insertion_point(field_get:RouteMsgStringResponse.id)
  return _internal_id();
}
inline void RouteMsgStringResponse::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:RouteMsgStringResponse.id)
}
inline ::uint64_t RouteMsgStringResponse::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void RouteMsgStringResponse::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = value;
}

// bool is_client = 5;
inline void RouteMsgStringResponse::clear_is_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_client_ = false;
}
inline bool RouteMsgStringResponse::is_client() const {
  // @@protoc_insertion_point(field_get:RouteMsgStringResponse.is_client)
  return _internal_is_client();
}
inline void RouteMsgStringResponse::set_is_client(bool value) {
  _internal_set_is_client(value);
  // @@protoc_insertion_point(field_set:RouteMsgStringResponse.is_client)
}
inline bool RouteMsgStringResponse::_internal_is_client() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_client_;
}
inline void RouteMsgStringResponse::_internal_set_is_client(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_client_ = value;
}

// -------------------------------------------------------------------

// RoutePlayerMsgStringRequest

// bytes body = 1;
inline void RoutePlayerMsgStringRequest::clear_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.ClearToEmpty();
}
inline const std::string& RoutePlayerMsgStringRequest::body() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RoutePlayerMsgStringRequest.body)
  return _internal_body();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RoutePlayerMsgStringRequest::set_body(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RoutePlayerMsgStringRequest.body)
}
inline std::string* RoutePlayerMsgStringRequest::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:RoutePlayerMsgStringRequest.body)
  return _s;
}
inline const std::string& RoutePlayerMsgStringRequest::_internal_body() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.body_.Get();
}
inline void RoutePlayerMsgStringRequest::_internal_set_body(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.Set(value, GetArena());
}
inline std::string* RoutePlayerMsgStringRequest::_internal_mutable_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.body_.Mutable( GetArena());
}
inline std::string* RoutePlayerMsgStringRequest::release_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RoutePlayerMsgStringRequest.body)
  return _impl_.body_.Release();
}
inline void RoutePlayerMsgStringRequest::set_allocated_body(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.body_.IsDefault()) {
          _impl_.body_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RoutePlayerMsgStringRequest.body)
}

// repeated .NodeInfo node_list = 2;
inline int RoutePlayerMsgStringRequest::_internal_node_list_size() const {
  return _internal_node_list().size();
}
inline int RoutePlayerMsgStringRequest::node_list_size() const {
  return _internal_node_list_size();
}
inline ::NodeInfo* RoutePlayerMsgStringRequest::mutable_node_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:RoutePlayerMsgStringRequest.node_list)
  return _internal_mutable_node_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::NodeInfo>* RoutePlayerMsgStringRequest::mutable_node_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:RoutePlayerMsgStringRequest.node_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_node_list();
}
inline const ::NodeInfo& RoutePlayerMsgStringRequest::node_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RoutePlayerMsgStringRequest.node_list)
  return _internal_node_list().Get(index);
}
inline ::NodeInfo* RoutePlayerMsgStringRequest::add_node_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NodeInfo* _add = _internal_mutable_node_list()->Add();
  // @@protoc_insertion_point(field_add:RoutePlayerMsgStringRequest.node_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::NodeInfo>& RoutePlayerMsgStringRequest::node_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:RoutePlayerMsgStringRequest.node_list)
  return _internal_node_list();
}
inline const ::google::protobuf::RepeatedPtrField<::NodeInfo>&
RoutePlayerMsgStringRequest::_internal_node_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_list_;
}
inline ::google::protobuf::RepeatedPtrField<::NodeInfo>*
RoutePlayerMsgStringRequest::_internal_mutable_node_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.node_list_;
}

// .PlayerMessageExtern player_ex = 3;
inline bool RoutePlayerMsgStringRequest::has_player_ex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ex_ != nullptr);
  return value;
}
inline void RoutePlayerMsgStringRequest::clear_player_ex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ex_ != nullptr) _impl_.player_ex_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::PlayerMessageExtern& RoutePlayerMsgStringRequest::_internal_player_ex() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::PlayerMessageExtern* p = _impl_.player_ex_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerMessageExtern&>(::_PlayerMessageExtern_default_instance_);
}
inline const ::PlayerMessageExtern& RoutePlayerMsgStringRequest::player_ex() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RoutePlayerMsgStringRequest.player_ex)
  return _internal_player_ex();
}
inline void RoutePlayerMsgStringRequest::unsafe_arena_set_allocated_player_ex(::PlayerMessageExtern* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_ex_);
  }
  _impl_.player_ex_ = reinterpret_cast<::PlayerMessageExtern*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoutePlayerMsgStringRequest.player_ex)
}
inline ::PlayerMessageExtern* RoutePlayerMsgStringRequest::release_player_ex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PlayerMessageExtern* released = _impl_.player_ex_;
  _impl_.player_ex_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::PlayerMessageExtern* RoutePlayerMsgStringRequest::unsafe_arena_release_player_ex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RoutePlayerMsgStringRequest.player_ex)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PlayerMessageExtern* temp = _impl_.player_ex_;
  _impl_.player_ex_ = nullptr;
  return temp;
}
inline ::PlayerMessageExtern* RoutePlayerMsgStringRequest::_internal_mutable_player_ex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ex_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::PlayerMessageExtern>(GetArena());
    _impl_.player_ex_ = reinterpret_cast<::PlayerMessageExtern*>(p);
  }
  return _impl_.player_ex_;
}
inline ::PlayerMessageExtern* RoutePlayerMsgStringRequest::mutable_player_ex() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::PlayerMessageExtern* _msg = _internal_mutable_player_ex();
  // @@protoc_insertion_point(field_mutable:RoutePlayerMsgStringRequest.player_ex)
  return _msg;
}
inline void RoutePlayerMsgStringRequest::set_allocated_player_ex(::PlayerMessageExtern* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.player_ex_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ex_ = reinterpret_cast<::PlayerMessageExtern*>(value);
  // @@protoc_insertion_point(field_set_allocated:RoutePlayerMsgStringRequest.player_ex)
}

// -------------------------------------------------------------------

// RoutePlayerMsgStringResponse

// bytes body = 1;
inline void RoutePlayerMsgStringResponse::clear_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.ClearToEmpty();
}
inline const std::string& RoutePlayerMsgStringResponse::body() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RoutePlayerMsgStringResponse.body)
  return _internal_body();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RoutePlayerMsgStringResponse::set_body(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RoutePlayerMsgStringResponse.body)
}
inline std::string* RoutePlayerMsgStringResponse::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:RoutePlayerMsgStringResponse.body)
  return _s;
}
inline const std::string& RoutePlayerMsgStringResponse::_internal_body() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.body_.Get();
}
inline void RoutePlayerMsgStringResponse::_internal_set_body(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.Set(value, GetArena());
}
inline std::string* RoutePlayerMsgStringResponse::_internal_mutable_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.body_.Mutable( GetArena());
}
inline std::string* RoutePlayerMsgStringResponse::release_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RoutePlayerMsgStringResponse.body)
  return _impl_.body_.Release();
}
inline void RoutePlayerMsgStringResponse::set_allocated_body(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.body_.IsDefault()) {
          _impl_.body_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RoutePlayerMsgStringResponse.body)
}

// repeated .NodeInfo node_list = 2;
inline int RoutePlayerMsgStringResponse::_internal_node_list_size() const {
  return _internal_node_list().size();
}
inline int RoutePlayerMsgStringResponse::node_list_size() const {
  return _internal_node_list_size();
}
inline ::NodeInfo* RoutePlayerMsgStringResponse::mutable_node_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:RoutePlayerMsgStringResponse.node_list)
  return _internal_mutable_node_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::NodeInfo>* RoutePlayerMsgStringResponse::mutable_node_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:RoutePlayerMsgStringResponse.node_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_node_list();
}
inline const ::NodeInfo& RoutePlayerMsgStringResponse::node_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RoutePlayerMsgStringResponse.node_list)
  return _internal_node_list().Get(index);
}
inline ::NodeInfo* RoutePlayerMsgStringResponse::add_node_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NodeInfo* _add = _internal_mutable_node_list()->Add();
  // @@protoc_insertion_point(field_add:RoutePlayerMsgStringResponse.node_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::NodeInfo>& RoutePlayerMsgStringResponse::node_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:RoutePlayerMsgStringResponse.node_list)
  return _internal_node_list();
}
inline const ::google::protobuf::RepeatedPtrField<::NodeInfo>&
RoutePlayerMsgStringResponse::_internal_node_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_list_;
}
inline ::google::protobuf::RepeatedPtrField<::NodeInfo>*
RoutePlayerMsgStringResponse::_internal_mutable_node_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.node_list_;
}

// .PlayerMessageExtern player_ex = 3;
inline bool RoutePlayerMsgStringResponse::has_player_ex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ex_ != nullptr);
  return value;
}
inline void RoutePlayerMsgStringResponse::clear_player_ex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ex_ != nullptr) _impl_.player_ex_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::PlayerMessageExtern& RoutePlayerMsgStringResponse::_internal_player_ex() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::PlayerMessageExtern* p = _impl_.player_ex_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerMessageExtern&>(::_PlayerMessageExtern_default_instance_);
}
inline const ::PlayerMessageExtern& RoutePlayerMsgStringResponse::player_ex() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RoutePlayerMsgStringResponse.player_ex)
  return _internal_player_ex();
}
inline void RoutePlayerMsgStringResponse::unsafe_arena_set_allocated_player_ex(::PlayerMessageExtern* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_ex_);
  }
  _impl_.player_ex_ = reinterpret_cast<::PlayerMessageExtern*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoutePlayerMsgStringResponse.player_ex)
}
inline ::PlayerMessageExtern* RoutePlayerMsgStringResponse::release_player_ex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PlayerMessageExtern* released = _impl_.player_ex_;
  _impl_.player_ex_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::PlayerMessageExtern* RoutePlayerMsgStringResponse::unsafe_arena_release_player_ex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RoutePlayerMsgStringResponse.player_ex)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PlayerMessageExtern* temp = _impl_.player_ex_;
  _impl_.player_ex_ = nullptr;
  return temp;
}
inline ::PlayerMessageExtern* RoutePlayerMsgStringResponse::_internal_mutable_player_ex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ex_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::PlayerMessageExtern>(GetArena());
    _impl_.player_ex_ = reinterpret_cast<::PlayerMessageExtern*>(p);
  }
  return _impl_.player_ex_;
}
inline ::PlayerMessageExtern* RoutePlayerMsgStringResponse::mutable_player_ex() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::PlayerMessageExtern* _msg = _internal_mutable_player_ex();
  // @@protoc_insertion_point(field_mutable:RoutePlayerMsgStringResponse.player_ex)
  return _msg;
}
inline void RoutePlayerMsgStringResponse::set_allocated_player_ex(::PlayerMessageExtern* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.player_ex_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ex_ = reinterpret_cast<::PlayerMessageExtern*>(value);
  // @@protoc_insertion_point(field_set_allocated:RoutePlayerMsgStringResponse.player_ex)
}

// -------------------------------------------------------------------

// RegisterGameNodeRequest

// .NetworkAddress rpc_client = 1;
inline bool RegisterGameNodeRequest::has_rpc_client() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rpc_client_ != nullptr);
  return value;
}
inline const ::NetworkAddress& RegisterGameNodeRequest::_internal_rpc_client() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NetworkAddress* p = _impl_.rpc_client_;
  return p != nullptr ? *p : reinterpret_cast<const ::NetworkAddress&>(::_NetworkAddress_default_instance_);
}
inline const ::NetworkAddress& RegisterGameNodeRequest::rpc_client() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterGameNodeRequest.rpc_client)
  return _internal_rpc_client();
}
inline void RegisterGameNodeRequest::unsafe_arena_set_allocated_rpc_client(::NetworkAddress* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_client_);
  }
  _impl_.rpc_client_ = reinterpret_cast<::NetworkAddress*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterGameNodeRequest.rpc_client)
}
inline ::NetworkAddress* RegisterGameNodeRequest::release_rpc_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NetworkAddress* released = _impl_.rpc_client_;
  _impl_.rpc_client_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NetworkAddress* RegisterGameNodeRequest::unsafe_arena_release_rpc_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RegisterGameNodeRequest.rpc_client)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NetworkAddress* temp = _impl_.rpc_client_;
  _impl_.rpc_client_ = nullptr;
  return temp;
}
inline ::NetworkAddress* RegisterGameNodeRequest::_internal_mutable_rpc_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rpc_client_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NetworkAddress>(GetArena());
    _impl_.rpc_client_ = reinterpret_cast<::NetworkAddress*>(p);
  }
  return _impl_.rpc_client_;
}
inline ::NetworkAddress* RegisterGameNodeRequest::mutable_rpc_client() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::NetworkAddress* _msg = _internal_mutable_rpc_client();
  // @@protoc_insertion_point(field_mutable:RegisterGameNodeRequest.rpc_client)
  return _msg;
}
inline void RegisterGameNodeRequest::set_allocated_rpc_client(::NetworkAddress* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_client_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.rpc_client_ = reinterpret_cast<::NetworkAddress*>(value);
  // @@protoc_insertion_point(field_set_allocated:RegisterGameNodeRequest.rpc_client)
}

// .NetworkAddress rpc_server = 2;
inline bool RegisterGameNodeRequest::has_rpc_server() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rpc_server_ != nullptr);
  return value;
}
inline const ::NetworkAddress& RegisterGameNodeRequest::_internal_rpc_server() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NetworkAddress* p = _impl_.rpc_server_;
  return p != nullptr ? *p : reinterpret_cast<const ::NetworkAddress&>(::_NetworkAddress_default_instance_);
}
inline const ::NetworkAddress& RegisterGameNodeRequest::rpc_server() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterGameNodeRequest.rpc_server)
  return _internal_rpc_server();
}
inline void RegisterGameNodeRequest::unsafe_arena_set_allocated_rpc_server(::NetworkAddress* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_server_);
  }
  _impl_.rpc_server_ = reinterpret_cast<::NetworkAddress*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterGameNodeRequest.rpc_server)
}
inline ::NetworkAddress* RegisterGameNodeRequest::release_rpc_server() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NetworkAddress* released = _impl_.rpc_server_;
  _impl_.rpc_server_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NetworkAddress* RegisterGameNodeRequest::unsafe_arena_release_rpc_server() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RegisterGameNodeRequest.rpc_server)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NetworkAddress* temp = _impl_.rpc_server_;
  _impl_.rpc_server_ = nullptr;
  return temp;
}
inline ::NetworkAddress* RegisterGameNodeRequest::_internal_mutable_rpc_server() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rpc_server_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NetworkAddress>(GetArena());
    _impl_.rpc_server_ = reinterpret_cast<::NetworkAddress*>(p);
  }
  return _impl_.rpc_server_;
}
inline ::NetworkAddress* RegisterGameNodeRequest::mutable_rpc_server() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::NetworkAddress* _msg = _internal_mutable_rpc_server();
  // @@protoc_insertion_point(field_mutable:RegisterGameNodeRequest.rpc_server)
  return _msg;
}
inline void RegisterGameNodeRequest::set_allocated_rpc_server(::NetworkAddress* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_server_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rpc_server_ = reinterpret_cast<::NetworkAddress*>(value);
  // @@protoc_insertion_point(field_set_allocated:RegisterGameNodeRequest.rpc_server)
}

// uint32 game_node_id = 3;
inline void RegisterGameNodeRequest::clear_game_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_node_id_ = 0u;
}
inline ::uint32_t RegisterGameNodeRequest::game_node_id() const {
  // @@protoc_insertion_point(field_get:RegisterGameNodeRequest.game_node_id)
  return _internal_game_node_id();
}
inline void RegisterGameNodeRequest::set_game_node_id(::uint32_t value) {
  _internal_set_game_node_id(value);
  // @@protoc_insertion_point(field_set:RegisterGameNodeRequest.game_node_id)
}
inline ::uint32_t RegisterGameNodeRequest::_internal_game_node_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.game_node_id_;
}
inline void RegisterGameNodeRequest::_internal_set_game_node_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_node_id_ = value;
}

// uint32 server_type = 4;
inline void RegisterGameNodeRequest::clear_server_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.server_type_ = 0u;
}
inline ::uint32_t RegisterGameNodeRequest::server_type() const {
  // @@protoc_insertion_point(field_get:RegisterGameNodeRequest.server_type)
  return _internal_server_type();
}
inline void RegisterGameNodeRequest::set_server_type(::uint32_t value) {
  _internal_set_server_type(value);
  // @@protoc_insertion_point(field_set:RegisterGameNodeRequest.server_type)
}
inline ::uint32_t RegisterGameNodeRequest::_internal_server_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.server_type_;
}
inline void RegisterGameNodeRequest::_internal_set_server_type(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.server_type_ = value;
}

// -------------------------------------------------------------------

// RegisterGateNodeRequest

// .NetworkAddress rpc_client = 1;
inline bool RegisterGateNodeRequest::has_rpc_client() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rpc_client_ != nullptr);
  return value;
}
inline const ::NetworkAddress& RegisterGateNodeRequest::_internal_rpc_client() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NetworkAddress* p = _impl_.rpc_client_;
  return p != nullptr ? *p : reinterpret_cast<const ::NetworkAddress&>(::_NetworkAddress_default_instance_);
}
inline const ::NetworkAddress& RegisterGateNodeRequest::rpc_client() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterGateNodeRequest.rpc_client)
  return _internal_rpc_client();
}
inline void RegisterGateNodeRequest::unsafe_arena_set_allocated_rpc_client(::NetworkAddress* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_client_);
  }
  _impl_.rpc_client_ = reinterpret_cast<::NetworkAddress*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterGateNodeRequest.rpc_client)
}
inline ::NetworkAddress* RegisterGateNodeRequest::release_rpc_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NetworkAddress* released = _impl_.rpc_client_;
  _impl_.rpc_client_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NetworkAddress* RegisterGateNodeRequest::unsafe_arena_release_rpc_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RegisterGateNodeRequest.rpc_client)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NetworkAddress* temp = _impl_.rpc_client_;
  _impl_.rpc_client_ = nullptr;
  return temp;
}
inline ::NetworkAddress* RegisterGateNodeRequest::_internal_mutable_rpc_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rpc_client_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NetworkAddress>(GetArena());
    _impl_.rpc_client_ = reinterpret_cast<::NetworkAddress*>(p);
  }
  return _impl_.rpc_client_;
}
inline ::NetworkAddress* RegisterGateNodeRequest::mutable_rpc_client() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::NetworkAddress* _msg = _internal_mutable_rpc_client();
  // @@protoc_insertion_point(field_mutable:RegisterGateNodeRequest.rpc_client)
  return _msg;
}
inline void RegisterGateNodeRequest::set_allocated_rpc_client(::NetworkAddress* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_client_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.rpc_client_ = reinterpret_cast<::NetworkAddress*>(value);
  // @@protoc_insertion_point(field_set_allocated:RegisterGateNodeRequest.rpc_client)
}

// uint32 gate_node_id = 2;
inline void RegisterGateNodeRequest::clear_gate_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gate_node_id_ = 0u;
}
inline ::uint32_t RegisterGateNodeRequest::gate_node_id() const {
  // @@protoc_insertion_point(field_get:RegisterGateNodeRequest.gate_node_id)
  return _internal_gate_node_id();
}
inline void RegisterGateNodeRequest::set_gate_node_id(::uint32_t value) {
  _internal_set_gate_node_id(value);
  // @@protoc_insertion_point(field_set:RegisterGateNodeRequest.gate_node_id)
}
inline ::uint32_t RegisterGateNodeRequest::_internal_gate_node_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gate_node_id_;
}
inline void RegisterGateNodeRequest::_internal_set_gate_node_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gate_node_id_ = value;
}

// -------------------------------------------------------------------

// UnRegisterGameNodeRequest

// uint32 game_node_id = 1;
inline void UnRegisterGameNodeRequest::clear_game_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_node_id_ = 0u;
}
inline ::uint32_t UnRegisterGameNodeRequest::game_node_id() const {
  // @@protoc_insertion_point(field_get:UnRegisterGameNodeRequest.game_node_id)
  return _internal_game_node_id();
}
inline void UnRegisterGameNodeRequest::set_game_node_id(::uint32_t value) {
  _internal_set_game_node_id(value);
  // @@protoc_insertion_point(field_set:UnRegisterGameNodeRequest.game_node_id)
}
inline ::uint32_t UnRegisterGameNodeRequest::_internal_game_node_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.game_node_id_;
}
inline void UnRegisterGameNodeRequest::_internal_set_game_node_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_node_id_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_common_2fcommon_5fmessage_2eproto_2epb_2eh
