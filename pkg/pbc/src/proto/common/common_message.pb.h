// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/common/common_message.proto
// Protobuf C++ Version: 5.26.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fcommon_2fcommon_5fmessage_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fcommon_2fcommon_5fmessage_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 5026001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "proto/common/common.pb.h"
#include "proto/common/session.pb.h"
#include "proto/common/tip.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_proto_2fcommon_2fcommon_5fmessage_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_proto_2fcommon_2fcommon_5fmessage_2eproto;
class GateSessionDisconnectRequest;
struct GateSessionDisconnectRequestDefaultTypeInternal;
extern GateSessionDisconnectRequestDefaultTypeInternal _GateSessionDisconnectRequest_default_instance_;
class MessageContent;
struct MessageContentDefaultTypeInternal;
extern MessageContentDefaultTypeInternal _MessageContent_default_instance_;
class MyNestedMessage;
struct MyNestedMessageDefaultTypeInternal;
extern MyNestedMessageDefaultTypeInternal _MyNestedMessage_default_instance_;
class MyProtoMessage;
struct MyProtoMessageDefaultTypeInternal;
extern MyProtoMessageDefaultTypeInternal _MyProtoMessage_default_instance_;
class NodeMessageHeader;
struct NodeMessageHeaderDefaultTypeInternal;
extern NodeMessageHeaderDefaultTypeInternal _NodeMessageHeader_default_instance_;
class NodeRouteMessageRequest;
struct NodeRouteMessageRequestDefaultTypeInternal;
extern NodeRouteMessageRequestDefaultTypeInternal _NodeRouteMessageRequest_default_instance_;
class NodeRouteMessageResponse;
struct NodeRouteMessageResponseDefaultTypeInternal;
extern NodeRouteMessageResponseDefaultTypeInternal _NodeRouteMessageResponse_default_instance_;
class NodeRoutingMessageBody;
struct NodeRoutingMessageBodyDefaultTypeInternal;
extern NodeRoutingMessageBodyDefaultTypeInternal _NodeRoutingMessageBody_default_instance_;
class PlayerInfoExternal;
struct PlayerInfoExternalDefaultTypeInternal;
extern PlayerInfoExternalDefaultTypeInternal _PlayerInfoExternal_default_instance_;
class PlayerMessageResponse;
struct PlayerMessageResponseDefaultTypeInternal;
extern PlayerMessageResponseDefaultTypeInternal _PlayerMessageResponse_default_instance_;
class PlayerNodeServiceRequest;
struct PlayerNodeServiceRequestDefaultTypeInternal;
extern PlayerNodeServiceRequestDefaultTypeInternal _PlayerNodeServiceRequest_default_instance_;
class ProtoFieldCheckerTestPB;
struct ProtoFieldCheckerTestPBDefaultTypeInternal;
extern ProtoFieldCheckerTestPBDefaultTypeInternal _ProtoFieldCheckerTestPB_default_instance_;
class ProtoFieldCheckerTestSubPB;
struct ProtoFieldCheckerTestSubPBDefaultTypeInternal;
extern ProtoFieldCheckerTestSubPBDefaultTypeInternal _ProtoFieldCheckerTestSubPB_default_instance_;
class RegisterCentreSessionNodeRequest;
struct RegisterCentreSessionNodeRequestDefaultTypeInternal;
extern RegisterCentreSessionNodeRequestDefaultTypeInternal _RegisterCentreSessionNodeRequest_default_instance_;
class RegisterGameNodeRequest;
struct RegisterGameNodeRequestDefaultTypeInternal;
extern RegisterGameNodeRequestDefaultTypeInternal _RegisterGameNodeRequest_default_instance_;
class RegisterGameNodeSessionRequest;
struct RegisterGameNodeSessionRequestDefaultTypeInternal;
extern RegisterGameNodeSessionRequestDefaultTypeInternal _RegisterGameNodeSessionRequest_default_instance_;
class RegisterGameNodeSessionResponse;
struct RegisterGameNodeSessionResponseDefaultTypeInternal;
extern RegisterGameNodeSessionResponseDefaultTypeInternal _RegisterGameNodeSessionResponse_default_instance_;
class RegisterGateNodeRequest;
struct RegisterGateNodeRequestDefaultTypeInternal;
extern RegisterGateNodeRequestDefaultTypeInternal _RegisterGateNodeRequest_default_instance_;
class RegisterGateNodeSessionResponse;
struct RegisterGateNodeSessionResponseDefaultTypeInternal;
extern RegisterGateNodeSessionResponseDefaultTypeInternal _RegisterGateNodeSessionResponse_default_instance_;
class RegisterSessionCentreNodeResponse;
struct RegisterSessionCentreNodeResponseDefaultTypeInternal;
extern RegisterSessionCentreNodeResponseDefaultTypeInternal _RegisterSessionCentreNodeResponse_default_instance_;
class RouteMessageRequest;
struct RouteMessageRequestDefaultTypeInternal;
extern RouteMessageRequestDefaultTypeInternal _RouteMessageRequest_default_instance_;
class RouteMessageResponse;
struct RouteMessageResponseDefaultTypeInternal;
extern RouteMessageResponseDefaultTypeInternal _RouteMessageResponse_default_instance_;
class RoutePlayerMessageRequest;
struct RoutePlayerMessageRequestDefaultTypeInternal;
extern RoutePlayerMessageRequestDefaultTypeInternal _RoutePlayerMessageRequest_default_instance_;
class RoutePlayerMessageResponse;
struct RoutePlayerMessageResponseDefaultTypeInternal;
extern RoutePlayerMessageResponseDefaultTypeInternal _RoutePlayerMessageResponse_default_instance_;
class RoutingNodeInfo;
struct RoutingNodeInfoDefaultTypeInternal;
extern RoutingNodeInfoDefaultTypeInternal _RoutingNodeInfo_default_instance_;
class UnregisterGameNodeRequest;
struct UnregisterGameNodeRequestDefaultTypeInternal;
extern UnregisterGameNodeRequestDefaultTypeInternal _UnregisterGameNodeRequest_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google


// ===================================================================


// -------------------------------------------------------------------

class UnregisterGameNodeRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:UnregisterGameNodeRequest) */ {
 public:
  inline UnregisterGameNodeRequest() : UnregisterGameNodeRequest(nullptr) {}
  ~UnregisterGameNodeRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UnregisterGameNodeRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline UnregisterGameNodeRequest(const UnregisterGameNodeRequest& from) : UnregisterGameNodeRequest(nullptr, from) {}
  inline UnregisterGameNodeRequest(UnregisterGameNodeRequest&& from) noexcept
      : UnregisterGameNodeRequest(nullptr, std::move(from)) {}
  inline UnregisterGameNodeRequest& operator=(const UnregisterGameNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnregisterGameNodeRequest& operator=(UnregisterGameNodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnregisterGameNodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnregisterGameNodeRequest* internal_default_instance() {
    return reinterpret_cast<const UnregisterGameNodeRequest*>(
        &_UnregisterGameNodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(UnregisterGameNodeRequest& a, UnregisterGameNodeRequest& b) { a.Swap(&b); }
  inline void Swap(UnregisterGameNodeRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnregisterGameNodeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnregisterGameNodeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UnregisterGameNodeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UnregisterGameNodeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UnregisterGameNodeRequest& from) { UnregisterGameNodeRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UnregisterGameNodeRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "UnregisterGameNodeRequest"; }

 protected:
  explicit UnregisterGameNodeRequest(::google::protobuf::Arena* arena);
  UnregisterGameNodeRequest(::google::protobuf::Arena* arena, const UnregisterGameNodeRequest& from);
  UnregisterGameNodeRequest(::google::protobuf::Arena* arena, UnregisterGameNodeRequest&& from) noexcept
      : UnregisterGameNodeRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGameNodeIdFieldNumber = 1,
  };
  // uint32 game_node_id = 1;
  void clear_scene_node_id() ;
  ::uint32_t scene_node_id() const;
  void set_game_node_id(::uint32_t value);

  private:
  ::uint32_t _internal_scene_node_id() const;
  void _internal_set_game_node_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:UnregisterGameNodeRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t game_node_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class ProtoFieldCheckerTestSubPB final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ProtoFieldCheckerTestSubPB) */ {
 public:
  inline ProtoFieldCheckerTestSubPB() : ProtoFieldCheckerTestSubPB(nullptr) {}
  ~ProtoFieldCheckerTestSubPB() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ProtoFieldCheckerTestSubPB(
      ::google::protobuf::internal::ConstantInitialized);

  inline ProtoFieldCheckerTestSubPB(const ProtoFieldCheckerTestSubPB& from) : ProtoFieldCheckerTestSubPB(nullptr, from) {}
  inline ProtoFieldCheckerTestSubPB(ProtoFieldCheckerTestSubPB&& from) noexcept
      : ProtoFieldCheckerTestSubPB(nullptr, std::move(from)) {}
  inline ProtoFieldCheckerTestSubPB& operator=(const ProtoFieldCheckerTestSubPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtoFieldCheckerTestSubPB& operator=(ProtoFieldCheckerTestSubPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtoFieldCheckerTestSubPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtoFieldCheckerTestSubPB* internal_default_instance() {
    return reinterpret_cast<const ProtoFieldCheckerTestSubPB*>(
        &_ProtoFieldCheckerTestSubPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(ProtoFieldCheckerTestSubPB& a, ProtoFieldCheckerTestSubPB& b) { a.Swap(&b); }
  inline void Swap(ProtoFieldCheckerTestSubPB* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtoFieldCheckerTestSubPB* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtoFieldCheckerTestSubPB* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ProtoFieldCheckerTestSubPB>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProtoFieldCheckerTestSubPB& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ProtoFieldCheckerTestSubPB& from) { ProtoFieldCheckerTestSubPB::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProtoFieldCheckerTestSubPB* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ProtoFieldCheckerTestSubPB"; }

 protected:
  explicit ProtoFieldCheckerTestSubPB(::google::protobuf::Arena* arena);
  ProtoFieldCheckerTestSubPB(::google::protobuf::Arena* arena, const ProtoFieldCheckerTestSubPB& from);
  ProtoFieldCheckerTestSubPB(::google::protobuf::Arena* arena, ProtoFieldCheckerTestSubPB&& from) noexcept
      : ProtoFieldCheckerTestSubPB(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated string items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  const std::string& items(int index) const;
  std::string* mutable_items(int index);
  void set_items(int index, const std::string& value);
  void set_items(int index, std::string&& value);
  void set_items(int index, const char* value);
  void set_items(int index, const char* value, std::size_t size);
  void set_items(int index, absl::string_view value);
  std::string* add_items();
  void add_items(const std::string& value);
  void add_items(std::string&& value);
  void add_items(const char* value);
  void add_items(const char* value, std::size_t size);
  void add_items(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& items() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_items();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_items();

  public:
  // @@protoc_insertion_point(class_scope:ProtoFieldCheckerTestSubPB)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> items_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfoExternal final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PlayerInfoExternal) */ {
 public:
  inline PlayerInfoExternal() : PlayerInfoExternal(nullptr) {}
  ~PlayerInfoExternal() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerInfoExternal(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerInfoExternal(const PlayerInfoExternal& from) : PlayerInfoExternal(nullptr, from) {}
  inline PlayerInfoExternal(PlayerInfoExternal&& from) noexcept
      : PlayerInfoExternal(nullptr, std::move(from)) {}
  inline PlayerInfoExternal& operator=(const PlayerInfoExternal& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfoExternal& operator=(PlayerInfoExternal&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfoExternal& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfoExternal* internal_default_instance() {
    return reinterpret_cast<const PlayerInfoExternal*>(
        &_PlayerInfoExternal_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(PlayerInfoExternal& a, PlayerInfoExternal& b) { a.Swap(&b); }
  inline void Swap(PlayerInfoExternal* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfoExternal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfoExternal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlayerInfoExternal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerInfoExternal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerInfoExternal& from) { PlayerInfoExternal::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerInfoExternal* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PlayerInfoExternal"; }

 protected:
  explicit PlayerInfoExternal(::google::protobuf::Arena* arena);
  PlayerInfoExternal(::google::protobuf::Arena* arena, const PlayerInfoExternal& from);
  PlayerInfoExternal(::google::protobuf::Arena* arena, PlayerInfoExternal&& from) noexcept
      : PlayerInfoExternal(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // uint64 player_id = 1;
  void clear_player_id() ;
  ::uint64_t player_id() const;
  void set_player_id(::uint64_t value);

  private:
  ::uint64_t _internal_player_id() const;
  void _internal_set_player_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:PlayerInfoExternal)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t player_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class NodeMessageHeader final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NodeMessageHeader) */ {
 public:
  inline NodeMessageHeader() : NodeMessageHeader(nullptr) {}
  ~NodeMessageHeader() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeMessageHeader(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeMessageHeader(const NodeMessageHeader& from) : NodeMessageHeader(nullptr, from) {}
  inline NodeMessageHeader(NodeMessageHeader&& from) noexcept
      : NodeMessageHeader(nullptr, std::move(from)) {}
  inline NodeMessageHeader& operator=(const NodeMessageHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeMessageHeader& operator=(NodeMessageHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeMessageHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeMessageHeader* internal_default_instance() {
    return reinterpret_cast<const NodeMessageHeader*>(
        &_NodeMessageHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(NodeMessageHeader& a, NodeMessageHeader& b) { a.Swap(&b); }
  inline void Swap(NodeMessageHeader* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeMessageHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeMessageHeader* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NodeMessageHeader>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeMessageHeader& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeMessageHeader& from) { NodeMessageHeader::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeMessageHeader* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "NodeMessageHeader"; }

 protected:
  explicit NodeMessageHeader(::google::protobuf::Arena* arena);
  NodeMessageHeader(::google::protobuf::Arena* arena, const NodeMessageHeader& from);
  NodeMessageHeader(::google::protobuf::Arena* arena, NodeMessageHeader&& from) noexcept
      : NodeMessageHeader(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionIdFieldNumber = 2,
    kNodeIdFieldNumber = 1,
  };
  // uint64 session_id = 2;
  void clear_session_id() ;
  ::uint64_t session_id() const;
  void set_session_id(::uint64_t value);

  private:
  ::uint64_t _internal_session_id() const;
  void _internal_set_session_id(::uint64_t value);

  public:
  // uint32 node_id = 1;
  void clear_node_id() ;
  ::uint32_t node_id() const;
  void set_node_id(::uint32_t value);

  private:
  ::uint32_t _internal_node_id() const;
  void _internal_set_node_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:NodeMessageHeader)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t session_id_;
    ::uint32_t node_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class MyNestedMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MyNestedMessage) */ {
 public:
  inline MyNestedMessage() : MyNestedMessage(nullptr) {}
  ~MyNestedMessage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MyNestedMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline MyNestedMessage(const MyNestedMessage& from) : MyNestedMessage(nullptr, from) {}
  inline MyNestedMessage(MyNestedMessage&& from) noexcept
      : MyNestedMessage(nullptr, std::move(from)) {}
  inline MyNestedMessage& operator=(const MyNestedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MyNestedMessage& operator=(MyNestedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MyNestedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const MyNestedMessage* internal_default_instance() {
    return reinterpret_cast<const MyNestedMessage*>(
        &_MyNestedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(MyNestedMessage& a, MyNestedMessage& b) { a.Swap(&b); }
  inline void Swap(MyNestedMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MyNestedMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MyNestedMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<MyNestedMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MyNestedMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MyNestedMessage& from) { MyNestedMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MyNestedMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "MyNestedMessage"; }

 protected:
  explicit MyNestedMessage(::google::protobuf::Arena* arena);
  MyNestedMessage(::google::protobuf::Arena* arena, const MyNestedMessage& from);
  MyNestedMessage(::google::protobuf::Arena* arena, MyNestedMessage&& from) noexcept
      : MyNestedMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNestedInt64FieldFieldNumber = 2,
    kNestedInt32FieldFieldNumber = 1,
  };
  // int64 nested_int64_field = 2;
  void clear_nested_int64_field() ;
  ::int64_t nested_int64_field() const;
  void set_nested_int64_field(::int64_t value);

  private:
  ::int64_t _internal_nested_int64_field() const;
  void _internal_set_nested_int64_field(::int64_t value);

  public:
  // int32 nested_int32_field = 1;
  void clear_nested_int32_field() ;
  ::int32_t nested_int32_field() const;
  void set_nested_int32_field(::int32_t value);

  private:
  ::int32_t _internal_nested_int32_field() const;
  void _internal_set_nested_int32_field(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MyNestedMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t nested_int64_field_;
    ::int32_t nested_int32_field_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RoutingNodeInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RoutingNodeInfo) */ {
 public:
  inline RoutingNodeInfo() : RoutingNodeInfo(nullptr) {}
  ~RoutingNodeInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoutingNodeInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline RoutingNodeInfo(const RoutingNodeInfo& from) : RoutingNodeInfo(nullptr, from) {}
  inline RoutingNodeInfo(RoutingNodeInfo&& from) noexcept
      : RoutingNodeInfo(nullptr, std::move(from)) {}
  inline RoutingNodeInfo& operator=(const RoutingNodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingNodeInfo& operator=(RoutingNodeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutingNodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutingNodeInfo* internal_default_instance() {
    return reinterpret_cast<const RoutingNodeInfo*>(
        &_RoutingNodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(RoutingNodeInfo& a, RoutingNodeInfo& b) { a.Swap(&b); }
  inline void Swap(RoutingNodeInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingNodeInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutingNodeInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RoutingNodeInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoutingNodeInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoutingNodeInfo& from) { RoutingNodeInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoutingNodeInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RoutingNodeInfo"; }

 protected:
  explicit RoutingNodeInfo(::google::protobuf::Arena* arena);
  RoutingNodeInfo(::google::protobuf::Arena* arena, const RoutingNodeInfo& from);
  RoutingNodeInfo(::google::protobuf::Arena* arena, RoutingNodeInfo&& from) noexcept
      : RoutingNodeInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeInfoFieldNumber = 1,
    kMessageIdFieldNumber = 2,
  };
  // .NodeInfo node_info = 1;
  bool has_node_info() const;
  void clear_node_info() ;
  const ::NodeInfo& node_info() const;
  PROTOBUF_NODISCARD ::NodeInfo* release_node_info();
  ::NodeInfo* mutable_node_info();
  void set_allocated_node_info(::NodeInfo* value);
  void unsafe_arena_set_allocated_node_info(::NodeInfo* value);
  ::NodeInfo* unsafe_arena_release_node_info();

  private:
  const ::NodeInfo& _internal_node_info() const;
  ::NodeInfo* _internal_mutable_node_info();

  public:
  // uint32 message_id = 2;
  void clear_message_id() ;
  ::uint32_t message_id() const;
  void set_message_id(::uint32_t value);

  private:
  ::uint32_t _internal_message_id() const;
  void _internal_set_message_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:RoutingNodeInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::NodeInfo* node_info_;
    ::uint32_t message_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RoutePlayerMessageResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RoutePlayerMessageResponse) */ {
 public:
  inline RoutePlayerMessageResponse() : RoutePlayerMessageResponse(nullptr) {}
  ~RoutePlayerMessageResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoutePlayerMessageResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RoutePlayerMessageResponse(const RoutePlayerMessageResponse& from) : RoutePlayerMessageResponse(nullptr, from) {}
  inline RoutePlayerMessageResponse(RoutePlayerMessageResponse&& from) noexcept
      : RoutePlayerMessageResponse(nullptr, std::move(from)) {}
  inline RoutePlayerMessageResponse& operator=(const RoutePlayerMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutePlayerMessageResponse& operator=(RoutePlayerMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutePlayerMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutePlayerMessageResponse* internal_default_instance() {
    return reinterpret_cast<const RoutePlayerMessageResponse*>(
        &_RoutePlayerMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(RoutePlayerMessageResponse& a, RoutePlayerMessageResponse& b) { a.Swap(&b); }
  inline void Swap(RoutePlayerMessageResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutePlayerMessageResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutePlayerMessageResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RoutePlayerMessageResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoutePlayerMessageResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoutePlayerMessageResponse& from) { RoutePlayerMessageResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoutePlayerMessageResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RoutePlayerMessageResponse"; }

 protected:
  explicit RoutePlayerMessageResponse(::google::protobuf::Arena* arena);
  RoutePlayerMessageResponse(::google::protobuf::Arena* arena, const RoutePlayerMessageResponse& from);
  RoutePlayerMessageResponse(::google::protobuf::Arena* arena, RoutePlayerMessageResponse&& from) noexcept
      : RoutePlayerMessageResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeListFieldNumber = 2,
    kBodyFieldNumber = 1,
    kPlayerInfoFieldNumber = 3,
  };
  // repeated .NodeInfo node_list = 2;
  int node_list_size() const;
  private:
  int _internal_node_list_size() const;

  public:
  void clear_node_list() ;
  ::NodeInfo* mutable_node_list(int index);
  ::google::protobuf::RepeatedPtrField<::NodeInfo>* mutable_node_list();

  private:
  const ::google::protobuf::RepeatedPtrField<::NodeInfo>& _internal_node_list() const;
  ::google::protobuf::RepeatedPtrField<::NodeInfo>* _internal_mutable_node_list();
  public:
  const ::NodeInfo& node_list(int index) const;
  ::NodeInfo* add_node_list();
  const ::google::protobuf::RepeatedPtrField<::NodeInfo>& node_list() const;
  // bytes body = 1;
  void clear_body() ;
  const std::string& body() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_body(Arg_&& arg, Args_... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* value);

  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(
      const std::string& value);
  std::string* _internal_mutable_body();

  public:
  // .PlayerInfoExternal player_info = 3;
  bool has_player_info() const;
  void clear_player_info() ;
  const ::PlayerInfoExternal& player_info() const;
  PROTOBUF_NODISCARD ::PlayerInfoExternal* release_player_info();
  ::PlayerInfoExternal* mutable_player_info();
  void set_allocated_player_info(::PlayerInfoExternal* value);
  void unsafe_arena_set_allocated_player_info(::PlayerInfoExternal* value);
  ::PlayerInfoExternal* unsafe_arena_release_player_info();

  private:
  const ::PlayerInfoExternal& _internal_player_info() const;
  ::PlayerInfoExternal* _internal_mutable_player_info();

  public:
  // @@protoc_insertion_point(class_scope:RoutePlayerMessageResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NodeInfo > node_list_;
    ::google::protobuf::internal::ArenaStringPtr body_;
    ::PlayerInfoExternal* player_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RoutePlayerMessageRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RoutePlayerMessageRequest) */ {
 public:
  inline RoutePlayerMessageRequest() : RoutePlayerMessageRequest(nullptr) {}
  ~RoutePlayerMessageRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoutePlayerMessageRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RoutePlayerMessageRequest(const RoutePlayerMessageRequest& from) : RoutePlayerMessageRequest(nullptr, from) {}
  inline RoutePlayerMessageRequest(RoutePlayerMessageRequest&& from) noexcept
      : RoutePlayerMessageRequest(nullptr, std::move(from)) {}
  inline RoutePlayerMessageRequest& operator=(const RoutePlayerMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutePlayerMessageRequest& operator=(RoutePlayerMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutePlayerMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutePlayerMessageRequest* internal_default_instance() {
    return reinterpret_cast<const RoutePlayerMessageRequest*>(
        &_RoutePlayerMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(RoutePlayerMessageRequest& a, RoutePlayerMessageRequest& b) { a.Swap(&b); }
  inline void Swap(RoutePlayerMessageRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutePlayerMessageRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutePlayerMessageRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RoutePlayerMessageRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoutePlayerMessageRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoutePlayerMessageRequest& from) { RoutePlayerMessageRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoutePlayerMessageRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RoutePlayerMessageRequest"; }

 protected:
  explicit RoutePlayerMessageRequest(::google::protobuf::Arena* arena);
  RoutePlayerMessageRequest(::google::protobuf::Arena* arena, const RoutePlayerMessageRequest& from);
  RoutePlayerMessageRequest(::google::protobuf::Arena* arena, RoutePlayerMessageRequest&& from) noexcept
      : RoutePlayerMessageRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeListFieldNumber = 2,
    kBodyFieldNumber = 1,
    kPlayerInfoFieldNumber = 3,
  };
  // repeated .NodeInfo node_list = 2;
  int node_list_size() const;
  private:
  int _internal_node_list_size() const;

  public:
  void clear_node_list() ;
  ::NodeInfo* mutable_node_list(int index);
  ::google::protobuf::RepeatedPtrField<::NodeInfo>* mutable_node_list();

  private:
  const ::google::protobuf::RepeatedPtrField<::NodeInfo>& _internal_node_list() const;
  ::google::protobuf::RepeatedPtrField<::NodeInfo>* _internal_mutable_node_list();
  public:
  const ::NodeInfo& node_list(int index) const;
  ::NodeInfo* add_node_list();
  const ::google::protobuf::RepeatedPtrField<::NodeInfo>& node_list() const;
  // bytes body = 1;
  void clear_body() ;
  const std::string& body() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_body(Arg_&& arg, Args_... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* value);

  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(
      const std::string& value);
  std::string* _internal_mutable_body();

  public:
  // .PlayerInfoExternal player_info = 3;
  bool has_player_info() const;
  void clear_player_info() ;
  const ::PlayerInfoExternal& player_info() const;
  PROTOBUF_NODISCARD ::PlayerInfoExternal* release_player_info();
  ::PlayerInfoExternal* mutable_player_info();
  void set_allocated_player_info(::PlayerInfoExternal* value);
  void unsafe_arena_set_allocated_player_info(::PlayerInfoExternal* value);
  ::PlayerInfoExternal* unsafe_arena_release_player_info();

  private:
  const ::PlayerInfoExternal& _internal_player_info() const;
  ::PlayerInfoExternal* _internal_mutable_player_info();

  public:
  // @@protoc_insertion_point(class_scope:RoutePlayerMessageRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::NodeInfo > node_list_;
    ::google::protobuf::internal::ArenaStringPtr body_;
    ::PlayerInfoExternal* player_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RegisterSessionCentreNodeResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RegisterSessionCentreNodeResponse) */ {
 public:
  inline RegisterSessionCentreNodeResponse() : RegisterSessionCentreNodeResponse(nullptr) {}
  ~RegisterSessionCentreNodeResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterSessionCentreNodeResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterSessionCentreNodeResponse(const RegisterSessionCentreNodeResponse& from) : RegisterSessionCentreNodeResponse(nullptr, from) {}
  inline RegisterSessionCentreNodeResponse(RegisterSessionCentreNodeResponse&& from) noexcept
      : RegisterSessionCentreNodeResponse(nullptr, std::move(from)) {}
  inline RegisterSessionCentreNodeResponse& operator=(const RegisterSessionCentreNodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterSessionCentreNodeResponse& operator=(RegisterSessionCentreNodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterSessionCentreNodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterSessionCentreNodeResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterSessionCentreNodeResponse*>(
        &_RegisterSessionCentreNodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(RegisterSessionCentreNodeResponse& a, RegisterSessionCentreNodeResponse& b) { a.Swap(&b); }
  inline void Swap(RegisterSessionCentreNodeResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterSessionCentreNodeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterSessionCentreNodeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterSessionCentreNodeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterSessionCentreNodeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterSessionCentreNodeResponse& from) { RegisterSessionCentreNodeResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterSessionCentreNodeResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RegisterSessionCentreNodeResponse"; }

 protected:
  explicit RegisterSessionCentreNodeResponse(::google::protobuf::Arena* arena);
  RegisterSessionCentreNodeResponse(::google::protobuf::Arena* arena, const RegisterSessionCentreNodeResponse& from);
  RegisterSessionCentreNodeResponse(::google::protobuf::Arena* arena, RegisterSessionCentreNodeResponse&& from) noexcept
      : RegisterSessionCentreNodeResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionInfoFieldNumber = 1,
  };
  // .SessionDetails session_info = 1;
  bool has_session_info() const;
  void clear_session_info() ;
  const ::SessionDetails& session_info() const;
  PROTOBUF_NODISCARD ::SessionDetails* release_session_info();
  ::SessionDetails* mutable_session_info();
  void set_allocated_session_info(::SessionDetails* value);
  void unsafe_arena_set_allocated_session_info(::SessionDetails* value);
  ::SessionDetails* unsafe_arena_release_session_info();

  private:
  const ::SessionDetails& _internal_session_info() const;
  ::SessionDetails* _internal_mutable_session_info();

  public:
  // @@protoc_insertion_point(class_scope:RegisterSessionCentreNodeResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::SessionDetails* session_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RegisterGateNodeSessionResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RegisterGateNodeSessionResponse) */ {
 public:
  inline RegisterGateNodeSessionResponse() : RegisterGateNodeSessionResponse(nullptr) {}
  ~RegisterGateNodeSessionResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterGateNodeSessionResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterGateNodeSessionResponse(const RegisterGateNodeSessionResponse& from) : RegisterGateNodeSessionResponse(nullptr, from) {}
  inline RegisterGateNodeSessionResponse(RegisterGateNodeSessionResponse&& from) noexcept
      : RegisterGateNodeSessionResponse(nullptr, std::move(from)) {}
  inline RegisterGateNodeSessionResponse& operator=(const RegisterGateNodeSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterGateNodeSessionResponse& operator=(RegisterGateNodeSessionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterGateNodeSessionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterGateNodeSessionResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterGateNodeSessionResponse*>(
        &_RegisterGateNodeSessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(RegisterGateNodeSessionResponse& a, RegisterGateNodeSessionResponse& b) { a.Swap(&b); }
  inline void Swap(RegisterGateNodeSessionResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterGateNodeSessionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterGateNodeSessionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterGateNodeSessionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterGateNodeSessionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterGateNodeSessionResponse& from) { RegisterGateNodeSessionResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterGateNodeSessionResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RegisterGateNodeSessionResponse"; }

 protected:
  explicit RegisterGateNodeSessionResponse(::google::protobuf::Arena* arena);
  RegisterGateNodeSessionResponse(::google::protobuf::Arena* arena, const RegisterGateNodeSessionResponse& from);
  RegisterGateNodeSessionResponse(::google::protobuf::Arena* arena, RegisterGateNodeSessionResponse&& from) noexcept
      : RegisterGateNodeSessionResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionInfoFieldNumber = 1,
  };
  // .SessionDetails session_info = 1;
  bool has_session_info() const;
  void clear_session_info() ;
  const ::SessionDetails& session_info() const;
  PROTOBUF_NODISCARD ::SessionDetails* release_session_info();
  ::SessionDetails* mutable_session_info();
  void set_allocated_session_info(::SessionDetails* value);
  void unsafe_arena_set_allocated_session_info(::SessionDetails* value);
  ::SessionDetails* unsafe_arena_release_session_info();

  private:
  const ::SessionDetails& _internal_session_info() const;
  ::SessionDetails* _internal_mutable_session_info();

  public:
  // @@protoc_insertion_point(class_scope:RegisterGateNodeSessionResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::SessionDetails* session_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RegisterGateNodeRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RegisterGateNodeRequest) */ {
 public:
  inline RegisterGateNodeRequest() : RegisterGateNodeRequest(nullptr) {}
  ~RegisterGateNodeRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterGateNodeRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterGateNodeRequest(const RegisterGateNodeRequest& from) : RegisterGateNodeRequest(nullptr, from) {}
  inline RegisterGateNodeRequest(RegisterGateNodeRequest&& from) noexcept
      : RegisterGateNodeRequest(nullptr, std::move(from)) {}
  inline RegisterGateNodeRequest& operator=(const RegisterGateNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterGateNodeRequest& operator=(RegisterGateNodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterGateNodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterGateNodeRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterGateNodeRequest*>(
        &_RegisterGateNodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(RegisterGateNodeRequest& a, RegisterGateNodeRequest& b) { a.Swap(&b); }
  inline void Swap(RegisterGateNodeRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterGateNodeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterGateNodeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterGateNodeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterGateNodeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterGateNodeRequest& from) { RegisterGateNodeRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterGateNodeRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RegisterGateNodeRequest"; }

 protected:
  explicit RegisterGateNodeRequest(::google::protobuf::Arena* arena);
  RegisterGateNodeRequest(::google::protobuf::Arena* arena, const RegisterGateNodeRequest& from);
  RegisterGateNodeRequest(::google::protobuf::Arena* arena, RegisterGateNodeRequest&& from) noexcept
      : RegisterGateNodeRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRpcClientFieldNumber = 1,
    kGateNodeIdFieldNumber = 2,
  };
  // .NetworkAddress rpc_client = 1;
  bool has_rpc_client() const;
  void clear_rpc_client() ;
  const ::NetworkAddress& rpc_client() const;
  PROTOBUF_NODISCARD ::NetworkAddress* release_rpc_client();
  ::NetworkAddress* mutable_rpc_client();
  void set_allocated_rpc_client(::NetworkAddress* value);
  void unsafe_arena_set_allocated_rpc_client(::NetworkAddress* value);
  ::NetworkAddress* unsafe_arena_release_rpc_client();

  private:
  const ::NetworkAddress& _internal_rpc_client() const;
  ::NetworkAddress* _internal_mutable_rpc_client();

  public:
  // uint32 gate_node_id = 2;
  void clear_gate_node_id() ;
  ::uint32_t gate_node_id() const;
  void set_gate_node_id(::uint32_t value);

  private:
  ::uint32_t _internal_gate_node_id() const;
  void _internal_set_gate_node_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:RegisterGateNodeRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::NetworkAddress* rpc_client_;
    ::uint32_t gate_node_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RegisterGameNodeSessionResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RegisterGameNodeSessionResponse) */ {
 public:
  inline RegisterGameNodeSessionResponse() : RegisterGameNodeSessionResponse(nullptr) {}
  ~RegisterGameNodeSessionResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterGameNodeSessionResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterGameNodeSessionResponse(const RegisterGameNodeSessionResponse& from) : RegisterGameNodeSessionResponse(nullptr, from) {}
  inline RegisterGameNodeSessionResponse(RegisterGameNodeSessionResponse&& from) noexcept
      : RegisterGameNodeSessionResponse(nullptr, std::move(from)) {}
  inline RegisterGameNodeSessionResponse& operator=(const RegisterGameNodeSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterGameNodeSessionResponse& operator=(RegisterGameNodeSessionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterGameNodeSessionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterGameNodeSessionResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterGameNodeSessionResponse*>(
        &_RegisterGameNodeSessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(RegisterGameNodeSessionResponse& a, RegisterGameNodeSessionResponse& b) { a.Swap(&b); }
  inline void Swap(RegisterGameNodeSessionResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterGameNodeSessionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterGameNodeSessionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterGameNodeSessionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterGameNodeSessionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterGameNodeSessionResponse& from) { RegisterGameNodeSessionResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterGameNodeSessionResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RegisterGameNodeSessionResponse"; }

 protected:
  explicit RegisterGameNodeSessionResponse(::google::protobuf::Arena* arena);
  RegisterGameNodeSessionResponse(::google::protobuf::Arena* arena, const RegisterGameNodeSessionResponse& from);
  RegisterGameNodeSessionResponse(::google::protobuf::Arena* arena, RegisterGameNodeSessionResponse&& from) noexcept
      : RegisterGameNodeSessionResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionInfoFieldNumber = 1,
  };
  // .SessionDetails session_info = 1;
  bool has_session_info() const;
  void clear_session_info() ;
  const ::SessionDetails& session_info() const;
  PROTOBUF_NODISCARD ::SessionDetails* release_session_info();
  ::SessionDetails* mutable_session_info();
  void set_allocated_session_info(::SessionDetails* value);
  void unsafe_arena_set_allocated_session_info(::SessionDetails* value);
  ::SessionDetails* unsafe_arena_release_session_info();

  private:
  const ::SessionDetails& _internal_session_info() const;
  ::SessionDetails* _internal_mutable_session_info();

  public:
  // @@protoc_insertion_point(class_scope:RegisterGameNodeSessionResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::SessionDetails* session_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RegisterGameNodeSessionRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RegisterGameNodeSessionRequest) */ {
 public:
  inline RegisterGameNodeSessionRequest() : RegisterGameNodeSessionRequest(nullptr) {}
  ~RegisterGameNodeSessionRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterGameNodeSessionRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterGameNodeSessionRequest(const RegisterGameNodeSessionRequest& from) : RegisterGameNodeSessionRequest(nullptr, from) {}
  inline RegisterGameNodeSessionRequest(RegisterGameNodeSessionRequest&& from) noexcept
      : RegisterGameNodeSessionRequest(nullptr, std::move(from)) {}
  inline RegisterGameNodeSessionRequest& operator=(const RegisterGameNodeSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterGameNodeSessionRequest& operator=(RegisterGameNodeSessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterGameNodeSessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterGameNodeSessionRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterGameNodeSessionRequest*>(
        &_RegisterGameNodeSessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(RegisterGameNodeSessionRequest& a, RegisterGameNodeSessionRequest& b) { a.Swap(&b); }
  inline void Swap(RegisterGameNodeSessionRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterGameNodeSessionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterGameNodeSessionRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterGameNodeSessionRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterGameNodeSessionRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterGameNodeSessionRequest& from) { RegisterGameNodeSessionRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterGameNodeSessionRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RegisterGameNodeSessionRequest"; }

 protected:
  explicit RegisterGameNodeSessionRequest(::google::protobuf::Arena* arena);
  RegisterGameNodeSessionRequest(::google::protobuf::Arena* arena, const RegisterGameNodeSessionRequest& from);
  RegisterGameNodeSessionRequest(::google::protobuf::Arena* arena, RegisterGameNodeSessionRequest&& from) noexcept
      : RegisterGameNodeSessionRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionInfoFieldNumber = 1,
    kGameNodeIdFieldNumber = 2,
  };
  // .SessionDetails session_info = 1;
  bool has_session_info() const;
  void clear_session_info() ;
  const ::SessionDetails& session_info() const;
  PROTOBUF_NODISCARD ::SessionDetails* release_session_info();
  ::SessionDetails* mutable_session_info();
  void set_allocated_session_info(::SessionDetails* value);
  void unsafe_arena_set_allocated_session_info(::SessionDetails* value);
  ::SessionDetails* unsafe_arena_release_session_info();

  private:
  const ::SessionDetails& _internal_session_info() const;
  ::SessionDetails* _internal_mutable_session_info();

  public:
  // uint32 game_node_id = 2;
  void clear_scene_node_id() ;
  ::uint32_t scene_node_id() const;
  void set_game_node_id(::uint32_t value);

  private:
  ::uint32_t _internal_scene_node_id() const;
  void _internal_set_game_node_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:RegisterGameNodeSessionRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::SessionDetails* session_info_;
    ::uint32_t game_node_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RegisterGameNodeRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RegisterGameNodeRequest) */ {
 public:
  inline RegisterGameNodeRequest() : RegisterGameNodeRequest(nullptr) {}
  ~RegisterGameNodeRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterGameNodeRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterGameNodeRequest(const RegisterGameNodeRequest& from) : RegisterGameNodeRequest(nullptr, from) {}
  inline RegisterGameNodeRequest(RegisterGameNodeRequest&& from) noexcept
      : RegisterGameNodeRequest(nullptr, std::move(from)) {}
  inline RegisterGameNodeRequest& operator=(const RegisterGameNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterGameNodeRequest& operator=(RegisterGameNodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterGameNodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterGameNodeRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterGameNodeRequest*>(
        &_RegisterGameNodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(RegisterGameNodeRequest& a, RegisterGameNodeRequest& b) { a.Swap(&b); }
  inline void Swap(RegisterGameNodeRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterGameNodeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterGameNodeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterGameNodeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterGameNodeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterGameNodeRequest& from) { RegisterGameNodeRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterGameNodeRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RegisterGameNodeRequest"; }

 protected:
  explicit RegisterGameNodeRequest(::google::protobuf::Arena* arena);
  RegisterGameNodeRequest(::google::protobuf::Arena* arena, const RegisterGameNodeRequest& from);
  RegisterGameNodeRequest(::google::protobuf::Arena* arena, RegisterGameNodeRequest&& from) noexcept
      : RegisterGameNodeRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRpcClientFieldNumber = 1,
    kRpcServerFieldNumber = 2,
    kSceneNodeIdFieldNumber = 3,
    kServerTypeFieldNumber = 4,
    kSceneNodeTypeFieldNumber = 5,
  };
  // .NetworkAddress rpc_client = 1;
  bool has_rpc_client() const;
  void clear_rpc_client() ;
  const ::NetworkAddress& rpc_client() const;
  PROTOBUF_NODISCARD ::NetworkAddress* release_rpc_client();
  ::NetworkAddress* mutable_rpc_client();
  void set_allocated_rpc_client(::NetworkAddress* value);
  void unsafe_arena_set_allocated_rpc_client(::NetworkAddress* value);
  ::NetworkAddress* unsafe_arena_release_rpc_client();

  private:
  const ::NetworkAddress& _internal_rpc_client() const;
  ::NetworkAddress* _internal_mutable_rpc_client();

  public:
  // .NetworkAddress rpc_server = 2;
  bool has_rpc_server() const;
  void clear_rpc_server() ;
  const ::NetworkAddress& rpc_server() const;
  PROTOBUF_NODISCARD ::NetworkAddress* release_rpc_server();
  ::NetworkAddress* mutable_rpc_server();
  void set_allocated_rpc_server(::NetworkAddress* value);
  void unsafe_arena_set_allocated_rpc_server(::NetworkAddress* value);
  ::NetworkAddress* unsafe_arena_release_rpc_server();

  private:
  const ::NetworkAddress& _internal_rpc_server() const;
  ::NetworkAddress* _internal_mutable_rpc_server();

  public:
  // uint32 scene_node_id = 3;
  void clear_scene_node_id() ;
  ::uint32_t scene_node_id() const;
  void set_scene_node_id(::uint32_t value);

  private:
  ::uint32_t _internal_scene_node_id() const;
  void _internal_set_scene_node_id(::uint32_t value);

  public:
  // uint32 server_type = 4;
  void clear_server_type() ;
  ::uint32_t server_type() const;
  void set_server_type(::uint32_t value);

  private:
  ::uint32_t _internal_server_type() const;
  void _internal_set_server_type(::uint32_t value);

  public:
  // uint32 scene_node_type = 5;
  void clear_scene_node_type() ;
  ::uint32_t scene_node_type() const;
  void set_scene_node_type(::uint32_t value);

  private:
  ::uint32_t _internal_scene_node_type() const;
  void _internal_set_scene_node_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:RegisterGameNodeRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::NetworkAddress* rpc_client_;
    ::NetworkAddress* rpc_server_;
    ::uint32_t scene_node_id_;
    ::uint32_t server_type_;
    ::uint32_t scene_node_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RegisterCentreSessionNodeRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RegisterCentreSessionNodeRequest) */ {
 public:
  inline RegisterCentreSessionNodeRequest() : RegisterCentreSessionNodeRequest(nullptr) {}
  ~RegisterCentreSessionNodeRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterCentreSessionNodeRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterCentreSessionNodeRequest(const RegisterCentreSessionNodeRequest& from) : RegisterCentreSessionNodeRequest(nullptr, from) {}
  inline RegisterCentreSessionNodeRequest(RegisterCentreSessionNodeRequest&& from) noexcept
      : RegisterCentreSessionNodeRequest(nullptr, std::move(from)) {}
  inline RegisterCentreSessionNodeRequest& operator=(const RegisterCentreSessionNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterCentreSessionNodeRequest& operator=(RegisterCentreSessionNodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterCentreSessionNodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterCentreSessionNodeRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterCentreSessionNodeRequest*>(
        &_RegisterCentreSessionNodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(RegisterCentreSessionNodeRequest& a, RegisterCentreSessionNodeRequest& b) { a.Swap(&b); }
  inline void Swap(RegisterCentreSessionNodeRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterCentreSessionNodeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterCentreSessionNodeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterCentreSessionNodeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterCentreSessionNodeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterCentreSessionNodeRequest& from) { RegisterCentreSessionNodeRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterCentreSessionNodeRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RegisterCentreSessionNodeRequest"; }

 protected:
  explicit RegisterCentreSessionNodeRequest(::google::protobuf::Arena* arena);
  RegisterCentreSessionNodeRequest(::google::protobuf::Arena* arena, const RegisterCentreSessionNodeRequest& from);
  RegisterCentreSessionNodeRequest(::google::protobuf::Arena* arena, RegisterCentreSessionNodeRequest&& from) noexcept
      : RegisterCentreSessionNodeRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionInfoFieldNumber = 1,
    kCentreNodeIdFieldNumber = 2,
  };
  // .SessionDetails session_info = 1;
  bool has_session_info() const;
  void clear_session_info() ;
  const ::SessionDetails& session_info() const;
  PROTOBUF_NODISCARD ::SessionDetails* release_session_info();
  ::SessionDetails* mutable_session_info();
  void set_allocated_session_info(::SessionDetails* value);
  void unsafe_arena_set_allocated_session_info(::SessionDetails* value);
  ::SessionDetails* unsafe_arena_release_session_info();

  private:
  const ::SessionDetails& _internal_session_info() const;
  ::SessionDetails* _internal_mutable_session_info();

  public:
  // uint32 centre_node_id = 2;
  void clear_centre_node_id() ;
  ::uint32_t centre_node_id() const;
  void set_centre_node_id(::uint32_t value);

  private:
  ::uint32_t _internal_centre_node_id() const;
  void _internal_set_centre_node_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:RegisterCentreSessionNodeRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::SessionDetails* session_info_;
    ::uint32_t centre_node_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class ProtoFieldCheckerTestPB final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ProtoFieldCheckerTestPB) */ {
 public:
  inline ProtoFieldCheckerTestPB() : ProtoFieldCheckerTestPB(nullptr) {}
  ~ProtoFieldCheckerTestPB() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ProtoFieldCheckerTestPB(
      ::google::protobuf::internal::ConstantInitialized);

  inline ProtoFieldCheckerTestPB(const ProtoFieldCheckerTestPB& from) : ProtoFieldCheckerTestPB(nullptr, from) {}
  inline ProtoFieldCheckerTestPB(ProtoFieldCheckerTestPB&& from) noexcept
      : ProtoFieldCheckerTestPB(nullptr, std::move(from)) {}
  inline ProtoFieldCheckerTestPB& operator=(const ProtoFieldCheckerTestPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtoFieldCheckerTestPB& operator=(ProtoFieldCheckerTestPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtoFieldCheckerTestPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtoFieldCheckerTestPB* internal_default_instance() {
    return reinterpret_cast<const ProtoFieldCheckerTestPB*>(
        &_ProtoFieldCheckerTestPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(ProtoFieldCheckerTestPB& a, ProtoFieldCheckerTestPB& b) { a.Swap(&b); }
  inline void Swap(ProtoFieldCheckerTestPB* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtoFieldCheckerTestPB* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtoFieldCheckerTestPB* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ProtoFieldCheckerTestPB>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProtoFieldCheckerTestPB& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ProtoFieldCheckerTestPB& from) { ProtoFieldCheckerTestPB::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProtoFieldCheckerTestPB* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ProtoFieldCheckerTestPB"; }

 protected:
  explicit ProtoFieldCheckerTestPB(::google::protobuf::Arena* arena);
  ProtoFieldCheckerTestPB(::google::protobuf::Arena* arena, const ProtoFieldCheckerTestPB& from);
  ProtoFieldCheckerTestPB(::google::protobuf::Arena* arena, ProtoFieldCheckerTestPB&& from) noexcept
      : ProtoFieldCheckerTestPB(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSubMessageFieldNumber = 1,
  };
  // .ProtoFieldCheckerTestSubPB sub_message = 1;
  bool has_sub_message() const;
  void clear_sub_message() ;
  const ::ProtoFieldCheckerTestSubPB& sub_message() const;
  PROTOBUF_NODISCARD ::ProtoFieldCheckerTestSubPB* release_sub_message();
  ::ProtoFieldCheckerTestSubPB* mutable_sub_message();
  void set_allocated_sub_message(::ProtoFieldCheckerTestSubPB* value);
  void unsafe_arena_set_allocated_sub_message(::ProtoFieldCheckerTestSubPB* value);
  ::ProtoFieldCheckerTestSubPB* unsafe_arena_release_sub_message();

  private:
  const ::ProtoFieldCheckerTestSubPB& _internal_sub_message() const;
  ::ProtoFieldCheckerTestSubPB* _internal_mutable_sub_message();

  public:
  // @@protoc_insertion_point(class_scope:ProtoFieldCheckerTestPB)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::ProtoFieldCheckerTestSubPB* sub_message_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class NodeRoutingMessageBody final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NodeRoutingMessageBody) */ {
 public:
  inline NodeRoutingMessageBody() : NodeRoutingMessageBody(nullptr) {}
  ~NodeRoutingMessageBody() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeRoutingMessageBody(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeRoutingMessageBody(const NodeRoutingMessageBody& from) : NodeRoutingMessageBody(nullptr, from) {}
  inline NodeRoutingMessageBody(NodeRoutingMessageBody&& from) noexcept
      : NodeRoutingMessageBody(nullptr, std::move(from)) {}
  inline NodeRoutingMessageBody& operator=(const NodeRoutingMessageBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeRoutingMessageBody& operator=(NodeRoutingMessageBody&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeRoutingMessageBody& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeRoutingMessageBody* internal_default_instance() {
    return reinterpret_cast<const NodeRoutingMessageBody*>(
        &_NodeRoutingMessageBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(NodeRoutingMessageBody& a, NodeRoutingMessageBody& b) { a.Swap(&b); }
  inline void Swap(NodeRoutingMessageBody* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeRoutingMessageBody* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeRoutingMessageBody* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NodeRoutingMessageBody>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeRoutingMessageBody& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeRoutingMessageBody& from) { NodeRoutingMessageBody::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeRoutingMessageBody* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "NodeRoutingMessageBody"; }

 protected:
  explicit NodeRoutingMessageBody(::google::protobuf::Arena* arena);
  NodeRoutingMessageBody(::google::protobuf::Arena* arena, const NodeRoutingMessageBody& from);
  NodeRoutingMessageBody(::google::protobuf::Arena* arena, NodeRoutingMessageBody&& from) noexcept
      : NodeRoutingMessageBody(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeInfoFieldNumber = 2,
  };
  // .NodeInfo node_info = 2;
  bool has_node_info() const;
  void clear_node_info() ;
  const ::NodeInfo& node_info() const;
  PROTOBUF_NODISCARD ::NodeInfo* release_node_info();
  ::NodeInfo* mutable_node_info();
  void set_allocated_node_info(::NodeInfo* value);
  void unsafe_arena_set_allocated_node_info(::NodeInfo* value);
  ::NodeInfo* unsafe_arena_release_node_info();

  private:
  const ::NodeInfo& _internal_node_info() const;
  ::NodeInfo* _internal_mutable_node_info();

  public:
  // @@protoc_insertion_point(class_scope:NodeRoutingMessageBody)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::NodeInfo* node_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class MyProtoMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MyProtoMessage) */ {
 public:
  inline MyProtoMessage() : MyProtoMessage(nullptr) {}
  ~MyProtoMessage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MyProtoMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline MyProtoMessage(const MyProtoMessage& from) : MyProtoMessage(nullptr, from) {}
  inline MyProtoMessage(MyProtoMessage&& from) noexcept
      : MyProtoMessage(nullptr, std::move(from)) {}
  inline MyProtoMessage& operator=(const MyProtoMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MyProtoMessage& operator=(MyProtoMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MyProtoMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const MyProtoMessage* internal_default_instance() {
    return reinterpret_cast<const MyProtoMessage*>(
        &_MyProtoMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(MyProtoMessage& a, MyProtoMessage& b) { a.Swap(&b); }
  inline void Swap(MyProtoMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MyProtoMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MyProtoMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<MyProtoMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MyProtoMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MyProtoMessage& from) { MyProtoMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MyProtoMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "MyProtoMessage"; }

 protected:
  explicit MyProtoMessage(::google::protobuf::Arena* arena);
  MyProtoMessage(::google::protobuf::Arena* arena, const MyProtoMessage& from);
  MyProtoMessage(::google::protobuf::Arena* arena, MyProtoMessage&& from) noexcept
      : MyProtoMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRepeatedInt32FieldFieldNumber = 3,
    kRepeatedInt64FieldFieldNumber = 4,
    kNestedMessageFieldNumber = 5,
    kSingleInt64FieldFieldNumber = 2,
    kSingleInt32FieldFieldNumber = 1,
  };
  // repeated int32 repeated_int32_field = 3;
  int repeated_int32_field_size() const;
  private:
  int _internal_repeated_int32_field_size() const;

  public:
  void clear_repeated_int32_field() ;
  ::int32_t repeated_int32_field(int index) const;
  void set_repeated_int32_field(int index, ::int32_t value);
  void add_repeated_int32_field(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& repeated_int32_field() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_repeated_int32_field();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_repeated_int32_field() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_repeated_int32_field();

  public:
  // repeated int64 repeated_int64_field = 4;
  int repeated_int64_field_size() const;
  private:
  int _internal_repeated_int64_field_size() const;

  public:
  void clear_repeated_int64_field() ;
  ::int64_t repeated_int64_field(int index) const;
  void set_repeated_int64_field(int index, ::int64_t value);
  void add_repeated_int64_field(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& repeated_int64_field() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_repeated_int64_field();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_repeated_int64_field() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_repeated_int64_field();

  public:
  // .MyNestedMessage nested_message = 5;
  bool has_nested_message() const;
  void clear_nested_message() ;
  const ::MyNestedMessage& nested_message() const;
  PROTOBUF_NODISCARD ::MyNestedMessage* release_nested_message();
  ::MyNestedMessage* mutable_nested_message();
  void set_allocated_nested_message(::MyNestedMessage* value);
  void unsafe_arena_set_allocated_nested_message(::MyNestedMessage* value);
  ::MyNestedMessage* unsafe_arena_release_nested_message();

  private:
  const ::MyNestedMessage& _internal_nested_message() const;
  ::MyNestedMessage* _internal_mutable_nested_message();

  public:
  // int64 single_int64_field = 2;
  void clear_single_int64_field() ;
  ::int64_t single_int64_field() const;
  void set_single_int64_field(::int64_t value);

  private:
  ::int64_t _internal_single_int64_field() const;
  void _internal_set_single_int64_field(::int64_t value);

  public:
  // int32 single_int32_field = 1;
  void clear_single_int32_field() ;
  ::int32_t single_int32_field() const;
  void set_single_int32_field(::int32_t value);

  private:
  ::int32_t _internal_single_int32_field() const;
  void _internal_set_single_int32_field(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MyProtoMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> repeated_int32_field_;
    mutable ::google::protobuf::internal::CachedSize _repeated_int32_field_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> repeated_int64_field_;
    mutable ::google::protobuf::internal::CachedSize _repeated_int64_field_cached_byte_size_;
    ::MyNestedMessage* nested_message_;
    ::int64_t single_int64_field_;
    ::int32_t single_int32_field_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class MessageContent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MessageContent) */ {
 public:
  inline MessageContent() : MessageContent(nullptr) {}
  ~MessageContent() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MessageContent(
      ::google::protobuf::internal::ConstantInitialized);

  inline MessageContent(const MessageContent& from) : MessageContent(nullptr, from) {}
  inline MessageContent(MessageContent&& from) noexcept
      : MessageContent(nullptr, std::move(from)) {}
  inline MessageContent& operator=(const MessageContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageContent& operator=(MessageContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageContent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageContent* internal_default_instance() {
    return reinterpret_cast<const MessageContent*>(
        &_MessageContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(MessageContent& a, MessageContent& b) { a.Swap(&b); }
  inline void Swap(MessageContent* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageContent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageContent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<MessageContent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MessageContent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MessageContent& from) { MessageContent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MessageContent* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "MessageContent"; }

 protected:
  explicit MessageContent(::google::protobuf::Arena* arena);
  MessageContent(::google::protobuf::Arena* arena, const MessageContent& from);
  MessageContent(::google::protobuf::Arena* arena, MessageContent&& from) noexcept
      : MessageContent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSerializedMessageFieldNumber = 1,
    kErrorMessageFieldNumber = 4,
    kIdFieldNumber = 3,
    kMessageIdFieldNumber = 2,
  };
  // bytes serialized_message = 1;
  void clear_serialized_message() ;
  const std::string& serialized_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_serialized_message(Arg_&& arg, Args_... args);
  std::string* mutable_serialized_message();
  PROTOBUF_NODISCARD std::string* release_serialized_message();
  void set_allocated_serialized_message(std::string* value);

  private:
  const std::string& _internal_serialized_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialized_message(
      const std::string& value);
  std::string* _internal_mutable_serialized_message();

  public:
  // .TipInfoMessage error_message = 4;
  bool has_error_message() const;
  void clear_error_message() ;
  const ::TipInfoMessage& error_message() const;
  PROTOBUF_NODISCARD ::TipInfoMessage* release_error_message();
  ::TipInfoMessage* mutable_error_message();
  void set_allocated_error_message(::TipInfoMessage* value);
  void unsafe_arena_set_allocated_error_message(::TipInfoMessage* value);
  ::TipInfoMessage* unsafe_arena_release_error_message();

  private:
  const ::TipInfoMessage& _internal_error_message() const;
  ::TipInfoMessage* _internal_mutable_error_message();

  public:
  // uint64 id = 3;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // uint32 message_id = 2;
  void clear_message_id() ;
  ::uint32_t message_id() const;
  void set_message_id(::uint32_t value);

  private:
  ::uint32_t _internal_message_id() const;
  void _internal_set_message_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MessageContent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr serialized_message_;
    ::TipInfoMessage* error_message_;
    ::uint64_t id_;
    ::uint32_t message_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class GateSessionDisconnectRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GateSessionDisconnectRequest) */ {
 public:
  inline GateSessionDisconnectRequest() : GateSessionDisconnectRequest(nullptr) {}
  ~GateSessionDisconnectRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GateSessionDisconnectRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GateSessionDisconnectRequest(const GateSessionDisconnectRequest& from) : GateSessionDisconnectRequest(nullptr, from) {}
  inline GateSessionDisconnectRequest(GateSessionDisconnectRequest&& from) noexcept
      : GateSessionDisconnectRequest(nullptr, std::move(from)) {}
  inline GateSessionDisconnectRequest& operator=(const GateSessionDisconnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GateSessionDisconnectRequest& operator=(GateSessionDisconnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GateSessionDisconnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GateSessionDisconnectRequest* internal_default_instance() {
    return reinterpret_cast<const GateSessionDisconnectRequest*>(
        &_GateSessionDisconnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(GateSessionDisconnectRequest& a, GateSessionDisconnectRequest& b) { a.Swap(&b); }
  inline void Swap(GateSessionDisconnectRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GateSessionDisconnectRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GateSessionDisconnectRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GateSessionDisconnectRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GateSessionDisconnectRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GateSessionDisconnectRequest& from) { GateSessionDisconnectRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GateSessionDisconnectRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GateSessionDisconnectRequest"; }

 protected:
  explicit GateSessionDisconnectRequest(::google::protobuf::Arena* arena);
  GateSessionDisconnectRequest(::google::protobuf::Arena* arena, const GateSessionDisconnectRequest& from);
  GateSessionDisconnectRequest(::google::protobuf::Arena* arena, GateSessionDisconnectRequest&& from) noexcept
      : GateSessionDisconnectRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionInfoFieldNumber = 1,
  };
  // .SessionDetails session_info = 1;
  bool has_session_info() const;
  void clear_session_info() ;
  const ::SessionDetails& session_info() const;
  PROTOBUF_NODISCARD ::SessionDetails* release_session_info();
  ::SessionDetails* mutable_session_info();
  void set_allocated_session_info(::SessionDetails* value);
  void unsafe_arena_set_allocated_session_info(::SessionDetails* value);
  ::SessionDetails* unsafe_arena_release_session_info();

  private:
  const ::SessionDetails& _internal_session_info() const;
  ::SessionDetails* _internal_mutable_session_info();

  public:
  // @@protoc_insertion_point(class_scope:GateSessionDisconnectRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::SessionDetails* session_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RouteMessageResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RouteMessageResponse) */ {
 public:
  inline RouteMessageResponse() : RouteMessageResponse(nullptr) {}
  ~RouteMessageResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RouteMessageResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RouteMessageResponse(const RouteMessageResponse& from) : RouteMessageResponse(nullptr, from) {}
  inline RouteMessageResponse(RouteMessageResponse&& from) noexcept
      : RouteMessageResponse(nullptr, std::move(from)) {}
  inline RouteMessageResponse& operator=(const RouteMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteMessageResponse& operator=(RouteMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteMessageResponse* internal_default_instance() {
    return reinterpret_cast<const RouteMessageResponse*>(
        &_RouteMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(RouteMessageResponse& a, RouteMessageResponse& b) { a.Swap(&b); }
  inline void Swap(RouteMessageResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteMessageResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteMessageResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RouteMessageResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouteMessageResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RouteMessageResponse& from) { RouteMessageResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouteMessageResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RouteMessageResponse"; }

 protected:
  explicit RouteMessageResponse(::google::protobuf::Arena* arena);
  RouteMessageResponse(::google::protobuf::Arena* arena, const RouteMessageResponse& from);
  RouteMessageResponse(::google::protobuf::Arena* arena, RouteMessageResponse&& from) noexcept
      : RouteMessageResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRouteNodesFieldNumber = 2,
    kBodyFieldNumber = 1,
    kSessionIdFieldNumber = 3,
    kIdFieldNumber = 4,
    kIsClientFieldNumber = 5,
  };
  // repeated .RoutingNodeInfo route_nodes = 2;
  int route_nodes_size() const;
  private:
  int _internal_route_nodes_size() const;

  public:
  void clear_route_nodes() ;
  ::RoutingNodeInfo* mutable_route_nodes(int index);
  ::google::protobuf::RepeatedPtrField<::RoutingNodeInfo>* mutable_route_nodes();

  private:
  const ::google::protobuf::RepeatedPtrField<::RoutingNodeInfo>& _internal_route_nodes() const;
  ::google::protobuf::RepeatedPtrField<::RoutingNodeInfo>* _internal_mutable_route_nodes();
  public:
  const ::RoutingNodeInfo& route_nodes(int index) const;
  ::RoutingNodeInfo* add_route_nodes();
  const ::google::protobuf::RepeatedPtrField<::RoutingNodeInfo>& route_nodes() const;
  // bytes body = 1;
  void clear_body() ;
  const std::string& body() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_body(Arg_&& arg, Args_... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* value);

  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(
      const std::string& value);
  std::string* _internal_mutable_body();

  public:
  // uint64 session_id = 3;
  void clear_session_id() ;
  ::uint64_t session_id() const;
  void set_session_id(::uint64_t value);

  private:
  ::uint64_t _internal_session_id() const;
  void _internal_set_session_id(::uint64_t value);

  public:
  // uint64 id = 4;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // bool is_client = 5;
  void clear_is_client() ;
  bool is_client() const;
  void set_is_client(bool value);

  private:
  bool _internal_is_client() const;
  void _internal_set_is_client(bool value);

  public:
  // @@protoc_insertion_point(class_scope:RouteMessageResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::RoutingNodeInfo > route_nodes_;
    ::google::protobuf::internal::ArenaStringPtr body_;
    ::uint64_t session_id_;
    ::uint64_t id_;
    bool is_client_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RouteMessageRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RouteMessageRequest) */ {
 public:
  inline RouteMessageRequest() : RouteMessageRequest(nullptr) {}
  ~RouteMessageRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RouteMessageRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RouteMessageRequest(const RouteMessageRequest& from) : RouteMessageRequest(nullptr, from) {}
  inline RouteMessageRequest(RouteMessageRequest&& from) noexcept
      : RouteMessageRequest(nullptr, std::move(from)) {}
  inline RouteMessageRequest& operator=(const RouteMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteMessageRequest& operator=(RouteMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteMessageRequest* internal_default_instance() {
    return reinterpret_cast<const RouteMessageRequest*>(
        &_RouteMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(RouteMessageRequest& a, RouteMessageRequest& b) { a.Swap(&b); }
  inline void Swap(RouteMessageRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteMessageRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteMessageRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RouteMessageRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouteMessageRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RouteMessageRequest& from) { RouteMessageRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouteMessageRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RouteMessageRequest"; }

 protected:
  explicit RouteMessageRequest(::google::protobuf::Arena* arena);
  RouteMessageRequest(::google::protobuf::Arena* arena, const RouteMessageRequest& from);
  RouteMessageRequest(::google::protobuf::Arena* arena, RouteMessageRequest&& from) noexcept
      : RouteMessageRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRouteNodesFieldNumber = 2,
    kBodyFieldNumber = 1,
    kSessionIdFieldNumber = 3,
    kIdFieldNumber = 4,
    kIsClientFieldNumber = 5,
  };
  // repeated .RoutingNodeInfo route_nodes = 2;
  int route_nodes_size() const;
  private:
  int _internal_route_nodes_size() const;

  public:
  void clear_route_nodes() ;
  ::RoutingNodeInfo* mutable_route_nodes(int index);
  ::google::protobuf::RepeatedPtrField<::RoutingNodeInfo>* mutable_route_nodes();

  private:
  const ::google::protobuf::RepeatedPtrField<::RoutingNodeInfo>& _internal_route_nodes() const;
  ::google::protobuf::RepeatedPtrField<::RoutingNodeInfo>* _internal_mutable_route_nodes();
  public:
  const ::RoutingNodeInfo& route_nodes(int index) const;
  ::RoutingNodeInfo* add_route_nodes();
  const ::google::protobuf::RepeatedPtrField<::RoutingNodeInfo>& route_nodes() const;
  // bytes body = 1;
  void clear_body() ;
  const std::string& body() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_body(Arg_&& arg, Args_... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* value);

  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(
      const std::string& value);
  std::string* _internal_mutable_body();

  public:
  // uint64 session_id = 3;
  void clear_session_id() ;
  ::uint64_t session_id() const;
  void set_session_id(::uint64_t value);

  private:
  ::uint64_t _internal_session_id() const;
  void _internal_set_session_id(::uint64_t value);

  public:
  // uint64 id = 4;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // bool is_client = 5;
  void clear_is_client() ;
  bool is_client() const;
  void set_is_client(bool value);

  private:
  bool _internal_is_client() const;
  void _internal_set_is_client(bool value);

  public:
  // @@protoc_insertion_point(class_scope:RouteMessageRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::RoutingNodeInfo > route_nodes_;
    ::google::protobuf::internal::ArenaStringPtr body_;
    ::uint64_t session_id_;
    ::uint64_t id_;
    bool is_client_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class PlayerNodeServiceRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PlayerNodeServiceRequest) */ {
 public:
  inline PlayerNodeServiceRequest() : PlayerNodeServiceRequest(nullptr) {}
  ~PlayerNodeServiceRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerNodeServiceRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerNodeServiceRequest(const PlayerNodeServiceRequest& from) : PlayerNodeServiceRequest(nullptr, from) {}
  inline PlayerNodeServiceRequest(PlayerNodeServiceRequest&& from) noexcept
      : PlayerNodeServiceRequest(nullptr, std::move(from)) {}
  inline PlayerNodeServiceRequest& operator=(const PlayerNodeServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerNodeServiceRequest& operator=(PlayerNodeServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerNodeServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerNodeServiceRequest* internal_default_instance() {
    return reinterpret_cast<const PlayerNodeServiceRequest*>(
        &_PlayerNodeServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(PlayerNodeServiceRequest& a, PlayerNodeServiceRequest& b) { a.Swap(&b); }
  inline void Swap(PlayerNodeServiceRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerNodeServiceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerNodeServiceRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlayerNodeServiceRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerNodeServiceRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerNodeServiceRequest& from) { PlayerNodeServiceRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerNodeServiceRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PlayerNodeServiceRequest"; }

 protected:
  explicit PlayerNodeServiceRequest(::google::protobuf::Arena* arena);
  PlayerNodeServiceRequest(::google::protobuf::Arena* arena, const PlayerNodeServiceRequest& from);
  PlayerNodeServiceRequest(::google::protobuf::Arena* arena, PlayerNodeServiceRequest&& from) noexcept
      : PlayerNodeServiceRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageContentFieldNumber = 1,
    kHeaderFieldNumber = 2,
  };
  // .MessageContent message_content = 1;
  bool has_message_content() const;
  void clear_message_content() ;
  const ::MessageContent& message_content() const;
  PROTOBUF_NODISCARD ::MessageContent* release_message_content();
  ::MessageContent* mutable_message_content();
  void set_allocated_message_content(::MessageContent* value);
  void unsafe_arena_set_allocated_message_content(::MessageContent* value);
  ::MessageContent* unsafe_arena_release_message_content();

  private:
  const ::MessageContent& _internal_message_content() const;
  ::MessageContent* _internal_mutable_message_content();

  public:
  // .PlayerInfoExternal header = 2;
  bool has_header() const;
  void clear_header() ;
  const ::PlayerInfoExternal& header() const;
  PROTOBUF_NODISCARD ::PlayerInfoExternal* release_header();
  ::PlayerInfoExternal* mutable_header();
  void set_allocated_header(::PlayerInfoExternal* value);
  void unsafe_arena_set_allocated_header(::PlayerInfoExternal* value);
  ::PlayerInfoExternal* unsafe_arena_release_header();

  private:
  const ::PlayerInfoExternal& _internal_header() const;
  ::PlayerInfoExternal* _internal_mutable_header();

  public:
  // @@protoc_insertion_point(class_scope:PlayerNodeServiceRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::MessageContent* message_content_;
    ::PlayerInfoExternal* header_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class PlayerMessageResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PlayerMessageResponse) */ {
 public:
  inline PlayerMessageResponse() : PlayerMessageResponse(nullptr) {}
  ~PlayerMessageResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerMessageResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayerMessageResponse(const PlayerMessageResponse& from) : PlayerMessageResponse(nullptr, from) {}
  inline PlayerMessageResponse(PlayerMessageResponse&& from) noexcept
      : PlayerMessageResponse(nullptr, std::move(from)) {}
  inline PlayerMessageResponse& operator=(const PlayerMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerMessageResponse& operator=(PlayerMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerMessageResponse* internal_default_instance() {
    return reinterpret_cast<const PlayerMessageResponse*>(
        &_PlayerMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(PlayerMessageResponse& a, PlayerMessageResponse& b) { a.Swap(&b); }
  inline void Swap(PlayerMessageResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerMessageResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerMessageResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlayerMessageResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerMessageResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerMessageResponse& from) { PlayerMessageResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerMessageResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PlayerMessageResponse"; }

 protected:
  explicit PlayerMessageResponse(::google::protobuf::Arena* arena);
  PlayerMessageResponse(::google::protobuf::Arena* arena, const PlayerMessageResponse& from);
  PlayerMessageResponse(::google::protobuf::Arena* arena, PlayerMessageResponse&& from) noexcept
      : PlayerMessageResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageContentFieldNumber = 1,
    kHeaderFieldNumber = 2,
  };
  // .MessageContent message_content = 1;
  bool has_message_content() const;
  void clear_message_content() ;
  const ::MessageContent& message_content() const;
  PROTOBUF_NODISCARD ::MessageContent* release_message_content();
  ::MessageContent* mutable_message_content();
  void set_allocated_message_content(::MessageContent* value);
  void unsafe_arena_set_allocated_message_content(::MessageContent* value);
  ::MessageContent* unsafe_arena_release_message_content();

  private:
  const ::MessageContent& _internal_message_content() const;
  ::MessageContent* _internal_mutable_message_content();

  public:
  // .PlayerInfoExternal header = 2;
  bool has_header() const;
  void clear_header() ;
  const ::PlayerInfoExternal& header() const;
  PROTOBUF_NODISCARD ::PlayerInfoExternal* release_header();
  ::PlayerInfoExternal* mutable_header();
  void set_allocated_header(::PlayerInfoExternal* value);
  void unsafe_arena_set_allocated_header(::PlayerInfoExternal* value);
  ::PlayerInfoExternal* unsafe_arena_release_header();

  private:
  const ::PlayerInfoExternal& _internal_header() const;
  ::PlayerInfoExternal* _internal_mutable_header();

  public:
  // @@protoc_insertion_point(class_scope:PlayerMessageResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::MessageContent* message_content_;
    ::PlayerInfoExternal* header_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class NodeRouteMessageResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NodeRouteMessageResponse) */ {
 public:
  inline NodeRouteMessageResponse() : NodeRouteMessageResponse(nullptr) {}
  ~NodeRouteMessageResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeRouteMessageResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeRouteMessageResponse(const NodeRouteMessageResponse& from) : NodeRouteMessageResponse(nullptr, from) {}
  inline NodeRouteMessageResponse(NodeRouteMessageResponse&& from) noexcept
      : NodeRouteMessageResponse(nullptr, std::move(from)) {}
  inline NodeRouteMessageResponse& operator=(const NodeRouteMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeRouteMessageResponse& operator=(NodeRouteMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeRouteMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeRouteMessageResponse* internal_default_instance() {
    return reinterpret_cast<const NodeRouteMessageResponse*>(
        &_NodeRouteMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(NodeRouteMessageResponse& a, NodeRouteMessageResponse& b) { a.Swap(&b); }
  inline void Swap(NodeRouteMessageResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeRouteMessageResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeRouteMessageResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NodeRouteMessageResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeRouteMessageResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeRouteMessageResponse& from) { NodeRouteMessageResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeRouteMessageResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "NodeRouteMessageResponse"; }

 protected:
  explicit NodeRouteMessageResponse(::google::protobuf::Arena* arena);
  NodeRouteMessageResponse(::google::protobuf::Arena* arena, const NodeRouteMessageResponse& from);
  NodeRouteMessageResponse(::google::protobuf::Arena* arena, NodeRouteMessageResponse&& from) noexcept
      : NodeRouteMessageResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageContentFieldNumber = 1,
    kHeaderFieldNumber = 2,
  };
  // .MessageContent message_content = 1;
  bool has_message_content() const;
  void clear_message_content() ;
  const ::MessageContent& message_content() const;
  PROTOBUF_NODISCARD ::MessageContent* release_message_content();
  ::MessageContent* mutable_message_content();
  void set_allocated_message_content(::MessageContent* value);
  void unsafe_arena_set_allocated_message_content(::MessageContent* value);
  ::MessageContent* unsafe_arena_release_message_content();

  private:
  const ::MessageContent& _internal_message_content() const;
  ::MessageContent* _internal_mutable_message_content();

  public:
  // .NodeMessageHeader header = 2;
  bool has_header() const;
  void clear_header() ;
  const ::NodeMessageHeader& header() const;
  PROTOBUF_NODISCARD ::NodeMessageHeader* release_header();
  ::NodeMessageHeader* mutable_header();
  void set_allocated_header(::NodeMessageHeader* value);
  void unsafe_arena_set_allocated_header(::NodeMessageHeader* value);
  ::NodeMessageHeader* unsafe_arena_release_header();

  private:
  const ::NodeMessageHeader& _internal_header() const;
  ::NodeMessageHeader* _internal_mutable_header();

  public:
  // @@protoc_insertion_point(class_scope:NodeRouteMessageResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::MessageContent* message_content_;
    ::NodeMessageHeader* header_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class NodeRouteMessageRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:NodeRouteMessageRequest) */ {
 public:
  inline NodeRouteMessageRequest() : NodeRouteMessageRequest(nullptr) {}
  ~NodeRouteMessageRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeRouteMessageRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeRouteMessageRequest(const NodeRouteMessageRequest& from) : NodeRouteMessageRequest(nullptr, from) {}
  inline NodeRouteMessageRequest(NodeRouteMessageRequest&& from) noexcept
      : NodeRouteMessageRequest(nullptr, std::move(from)) {}
  inline NodeRouteMessageRequest& operator=(const NodeRouteMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeRouteMessageRequest& operator=(NodeRouteMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeRouteMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeRouteMessageRequest* internal_default_instance() {
    return reinterpret_cast<const NodeRouteMessageRequest*>(
        &_NodeRouteMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(NodeRouteMessageRequest& a, NodeRouteMessageRequest& b) { a.Swap(&b); }
  inline void Swap(NodeRouteMessageRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeRouteMessageRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeRouteMessageRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NodeRouteMessageRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeRouteMessageRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeRouteMessageRequest& from) { NodeRouteMessageRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeRouteMessageRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "NodeRouteMessageRequest"; }

 protected:
  explicit NodeRouteMessageRequest(::google::protobuf::Arena* arena);
  NodeRouteMessageRequest(::google::protobuf::Arena* arena, const NodeRouteMessageRequest& from);
  NodeRouteMessageRequest(::google::protobuf::Arena* arena, NodeRouteMessageRequest&& from) noexcept
      : NodeRouteMessageRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageContentFieldNumber = 1,
    kHeaderFieldNumber = 2,
  };
  // .MessageContent message_content = 1;
  bool has_message_content() const;
  void clear_message_content() ;
  const ::MessageContent& message_content() const;
  PROTOBUF_NODISCARD ::MessageContent* release_message_content();
  ::MessageContent* mutable_message_content();
  void set_allocated_message_content(::MessageContent* value);
  void unsafe_arena_set_allocated_message_content(::MessageContent* value);
  ::MessageContent* unsafe_arena_release_message_content();

  private:
  const ::MessageContent& _internal_message_content() const;
  ::MessageContent* _internal_mutable_message_content();

  public:
  // .NodeMessageHeader header = 2;
  bool has_header() const;
  void clear_header() ;
  const ::NodeMessageHeader& header() const;
  PROTOBUF_NODISCARD ::NodeMessageHeader* release_header();
  ::NodeMessageHeader* mutable_header();
  void set_allocated_header(::NodeMessageHeader* value);
  void unsafe_arena_set_allocated_header(::NodeMessageHeader* value);
  ::NodeMessageHeader* unsafe_arena_release_header();

  private:
  const ::NodeMessageHeader& _internal_header() const;
  ::NodeMessageHeader* _internal_mutable_header();

  public:
  // @@protoc_insertion_point(class_scope:NodeRouteMessageRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::MessageContent* message_content_;
    ::NodeMessageHeader* header_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fcommon_2fcommon_5fmessage_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RoutingNodeInfo

// .NodeInfo node_info = 1;
inline bool RoutingNodeInfo::has_node_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.node_info_ != nullptr);
  return value;
}
inline const ::NodeInfo& RoutingNodeInfo::_internal_node_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NodeInfo* p = _impl_.node_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::NodeInfo&>(::_NodeInfo_default_instance_);
}
inline const ::NodeInfo& RoutingNodeInfo::node_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RoutingNodeInfo.node_info)
  return _internal_node_info();
}
inline void RoutingNodeInfo::unsafe_arena_set_allocated_node_info(::NodeInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_info_);
  }
  _impl_.node_info_ = reinterpret_cast<::NodeInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoutingNodeInfo.node_info)
}
inline ::NodeInfo* RoutingNodeInfo::release_node_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NodeInfo* released = _impl_.node_info_;
  _impl_.node_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NodeInfo* RoutingNodeInfo::unsafe_arena_release_node_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RoutingNodeInfo.node_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NodeInfo* temp = _impl_.node_info_;
  _impl_.node_info_ = nullptr;
  return temp;
}
inline ::NodeInfo* RoutingNodeInfo::_internal_mutable_node_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.node_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NodeInfo>(GetArena());
    _impl_.node_info_ = reinterpret_cast<::NodeInfo*>(p);
  }
  return _impl_.node_info_;
}
inline ::NodeInfo* RoutingNodeInfo::mutable_node_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::NodeInfo* _msg = _internal_mutable_node_info();
  // @@protoc_insertion_point(field_mutable:RoutingNodeInfo.node_info)
  return _msg;
}
inline void RoutingNodeInfo::set_allocated_node_info(::NodeInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.node_info_ = reinterpret_cast<::NodeInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:RoutingNodeInfo.node_info)
}

// uint32 message_id = 2;
inline void RoutingNodeInfo::clear_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_id_ = 0u;
}
inline ::uint32_t RoutingNodeInfo::message_id() const {
  // @@protoc_insertion_point(field_get:RoutingNodeInfo.message_id)
  return _internal_message_id();
}
inline void RoutingNodeInfo::set_message_id(::uint32_t value) {
  _internal_set_message_id(value);
  // @@protoc_insertion_point(field_set:RoutingNodeInfo.message_id)
}
inline ::uint32_t RoutingNodeInfo::_internal_message_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_id_;
}
inline void RoutingNodeInfo::_internal_set_message_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_id_ = value;
}

// -------------------------------------------------------------------

// MessageContent

// bytes serialized_message = 1;
inline void MessageContent::clear_serialized_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.serialized_message_.ClearToEmpty();
}
inline const std::string& MessageContent::serialized_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MessageContent.serialized_message)
  return _internal_serialized_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageContent::set_serialized_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.serialized_message_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MessageContent.serialized_message)
}
inline std::string* MessageContent::mutable_serialized_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_serialized_message();
  // @@protoc_insertion_point(field_mutable:MessageContent.serialized_message)
  return _s;
}
inline const std::string& MessageContent::_internal_serialized_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.serialized_message_.Get();
}
inline void MessageContent::_internal_set_serialized_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.serialized_message_.Set(value, GetArena());
}
inline std::string* MessageContent::_internal_mutable_serialized_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.serialized_message_.Mutable( GetArena());
}
inline std::string* MessageContent::release_serialized_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MessageContent.serialized_message)
  return _impl_.serialized_message_.Release();
}
inline void MessageContent::set_allocated_serialized_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.serialized_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.serialized_message_.IsDefault()) {
          _impl_.serialized_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MessageContent.serialized_message)
}

// uint32 message_id = 2;
inline void MessageContent::clear_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_id_ = 0u;
}
inline ::uint32_t MessageContent::message_id() const {
  // @@protoc_insertion_point(field_get:MessageContent.message_id)
  return _internal_message_id();
}
inline void MessageContent::set_message_id(::uint32_t value) {
  _internal_set_message_id(value);
  // @@protoc_insertion_point(field_set:MessageContent.message_id)
}
inline ::uint32_t MessageContent::_internal_message_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_id_;
}
inline void MessageContent::_internal_set_message_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_id_ = value;
}

// uint64 id = 3;
inline void MessageContent::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t MessageContent::id() const {
  // @@protoc_insertion_point(field_get:MessageContent.id)
  return _internal_id();
}
inline void MessageContent::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:MessageContent.id)
}
inline ::uint64_t MessageContent::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void MessageContent::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = value;
}

// .TipInfoMessage error_message = 4;
inline bool MessageContent::has_error_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_message_ != nullptr);
  return value;
}
inline const ::TipInfoMessage& MessageContent::_internal_error_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TipInfoMessage* p = _impl_.error_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::TipInfoMessage&>(::_TipInfoMessage_default_instance_);
}
inline const ::TipInfoMessage& MessageContent::error_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MessageContent.error_message)
  return _internal_error_message();
}
inline void MessageContent::unsafe_arena_set_allocated_error_message(::TipInfoMessage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_message_);
  }
  _impl_.error_message_ = reinterpret_cast<::TipInfoMessage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageContent.error_message)
}
inline ::TipInfoMessage* MessageContent::release_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TipInfoMessage* released = _impl_.error_message_;
  _impl_.error_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TipInfoMessage* MessageContent::unsafe_arena_release_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MessageContent.error_message)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TipInfoMessage* temp = _impl_.error_message_;
  _impl_.error_message_ = nullptr;
  return temp;
}
inline ::TipInfoMessage* MessageContent::_internal_mutable_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.error_message_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::TipInfoMessage>(GetArena());
    _impl_.error_message_ = reinterpret_cast<::TipInfoMessage*>(p);
  }
  return _impl_.error_message_;
}
inline ::TipInfoMessage* MessageContent::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::TipInfoMessage* _msg = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:MessageContent.error_message)
  return _msg;
}
inline void MessageContent::set_allocated_error_message(::TipInfoMessage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_message_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_message_ = reinterpret_cast<::TipInfoMessage*>(value);
  // @@protoc_insertion_point(field_set_allocated:MessageContent.error_message)
}

// -------------------------------------------------------------------

// NodeMessageHeader

// uint32 node_id = 1;
inline void NodeMessageHeader::clear_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_id_ = 0u;
}
inline ::uint32_t NodeMessageHeader::node_id() const {
  // @@protoc_insertion_point(field_get:NodeMessageHeader.node_id)
  return _internal_node_id();
}
inline void NodeMessageHeader::set_node_id(::uint32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:NodeMessageHeader.node_id)
}
inline ::uint32_t NodeMessageHeader::_internal_node_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_id_;
}
inline void NodeMessageHeader::_internal_set_node_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_id_ = value;
}

// uint64 session_id = 2;
inline void NodeMessageHeader::clear_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_ = ::uint64_t{0u};
}
inline ::uint64_t NodeMessageHeader::session_id() const {
  // @@protoc_insertion_point(field_get:NodeMessageHeader.session_id)
  return _internal_session_id();
}
inline void NodeMessageHeader::set_session_id(::uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:NodeMessageHeader.session_id)
}
inline ::uint64_t NodeMessageHeader::_internal_session_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.session_id_;
}
inline void NodeMessageHeader::_internal_set_session_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_ = value;
}

// -------------------------------------------------------------------

// NodeRouteMessageRequest

// .MessageContent message_content = 1;
inline bool NodeRouteMessageRequest::has_message_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.message_content_ != nullptr);
  return value;
}
inline void NodeRouteMessageRequest::clear_message_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.message_content_ != nullptr) _impl_.message_content_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MessageContent& NodeRouteMessageRequest::_internal_message_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::MessageContent* p = _impl_.message_content_;
  return p != nullptr ? *p : reinterpret_cast<const ::MessageContent&>(::_MessageContent_default_instance_);
}
inline const ::MessageContent& NodeRouteMessageRequest::message_content() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NodeRouteMessageRequest.message_content)
  return _internal_message_content();
}
inline void NodeRouteMessageRequest::unsafe_arena_set_allocated_message_content(::MessageContent* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.message_content_);
  }
  _impl_.message_content_ = reinterpret_cast<::MessageContent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NodeRouteMessageRequest.message_content)
}
inline ::MessageContent* NodeRouteMessageRequest::release_message_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MessageContent* released = _impl_.message_content_;
  _impl_.message_content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::MessageContent* NodeRouteMessageRequest::unsafe_arena_release_message_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NodeRouteMessageRequest.message_content)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MessageContent* temp = _impl_.message_content_;
  _impl_.message_content_ = nullptr;
  return temp;
}
inline ::MessageContent* NodeRouteMessageRequest::_internal_mutable_message_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.message_content_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::MessageContent>(GetArena());
    _impl_.message_content_ = reinterpret_cast<::MessageContent*>(p);
  }
  return _impl_.message_content_;
}
inline ::MessageContent* NodeRouteMessageRequest::mutable_message_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::MessageContent* _msg = _internal_mutable_message_content();
  // @@protoc_insertion_point(field_mutable:NodeRouteMessageRequest.message_content)
  return _msg;
}
inline void NodeRouteMessageRequest::set_allocated_message_content(::MessageContent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.message_content_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.message_content_ = reinterpret_cast<::MessageContent*>(value);
  // @@protoc_insertion_point(field_set_allocated:NodeRouteMessageRequest.message_content)
}

// .NodeMessageHeader header = 2;
inline bool NodeRouteMessageRequest::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void NodeRouteMessageRequest::clear_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::NodeMessageHeader& NodeRouteMessageRequest::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NodeMessageHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::NodeMessageHeader&>(::_NodeMessageHeader_default_instance_);
}
inline const ::NodeMessageHeader& NodeRouteMessageRequest::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NodeRouteMessageRequest.header)
  return _internal_header();
}
inline void NodeRouteMessageRequest::unsafe_arena_set_allocated_header(::NodeMessageHeader* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::NodeMessageHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NodeRouteMessageRequest.header)
}
inline ::NodeMessageHeader* NodeRouteMessageRequest::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NodeMessageHeader* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NodeMessageHeader* NodeRouteMessageRequest::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NodeRouteMessageRequest.header)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NodeMessageHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::NodeMessageHeader* NodeRouteMessageRequest::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NodeMessageHeader>(GetArena());
    _impl_.header_ = reinterpret_cast<::NodeMessageHeader*>(p);
  }
  return _impl_.header_;
}
inline ::NodeMessageHeader* NodeRouteMessageRequest::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::NodeMessageHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:NodeRouteMessageRequest.header)
  return _msg;
}
inline void NodeRouteMessageRequest::set_allocated_header(::NodeMessageHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.header_ = reinterpret_cast<::NodeMessageHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:NodeRouteMessageRequest.header)
}

// -------------------------------------------------------------------

// NodeRouteMessageResponse

// .MessageContent message_content = 1;
inline bool NodeRouteMessageResponse::has_message_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.message_content_ != nullptr);
  return value;
}
inline void NodeRouteMessageResponse::clear_message_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.message_content_ != nullptr) _impl_.message_content_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MessageContent& NodeRouteMessageResponse::_internal_message_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::MessageContent* p = _impl_.message_content_;
  return p != nullptr ? *p : reinterpret_cast<const ::MessageContent&>(::_MessageContent_default_instance_);
}
inline const ::MessageContent& NodeRouteMessageResponse::message_content() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NodeRouteMessageResponse.message_content)
  return _internal_message_content();
}
inline void NodeRouteMessageResponse::unsafe_arena_set_allocated_message_content(::MessageContent* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.message_content_);
  }
  _impl_.message_content_ = reinterpret_cast<::MessageContent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NodeRouteMessageResponse.message_content)
}
inline ::MessageContent* NodeRouteMessageResponse::release_message_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MessageContent* released = _impl_.message_content_;
  _impl_.message_content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::MessageContent* NodeRouteMessageResponse::unsafe_arena_release_message_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NodeRouteMessageResponse.message_content)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MessageContent* temp = _impl_.message_content_;
  _impl_.message_content_ = nullptr;
  return temp;
}
inline ::MessageContent* NodeRouteMessageResponse::_internal_mutable_message_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.message_content_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::MessageContent>(GetArena());
    _impl_.message_content_ = reinterpret_cast<::MessageContent*>(p);
  }
  return _impl_.message_content_;
}
inline ::MessageContent* NodeRouteMessageResponse::mutable_message_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::MessageContent* _msg = _internal_mutable_message_content();
  // @@protoc_insertion_point(field_mutable:NodeRouteMessageResponse.message_content)
  return _msg;
}
inline void NodeRouteMessageResponse::set_allocated_message_content(::MessageContent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.message_content_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.message_content_ = reinterpret_cast<::MessageContent*>(value);
  // @@protoc_insertion_point(field_set_allocated:NodeRouteMessageResponse.message_content)
}

// .NodeMessageHeader header = 2;
inline bool NodeRouteMessageResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void NodeRouteMessageResponse::clear_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::NodeMessageHeader& NodeRouteMessageResponse::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NodeMessageHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::NodeMessageHeader&>(::_NodeMessageHeader_default_instance_);
}
inline const ::NodeMessageHeader& NodeRouteMessageResponse::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NodeRouteMessageResponse.header)
  return _internal_header();
}
inline void NodeRouteMessageResponse::unsafe_arena_set_allocated_header(::NodeMessageHeader* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::NodeMessageHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NodeRouteMessageResponse.header)
}
inline ::NodeMessageHeader* NodeRouteMessageResponse::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NodeMessageHeader* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NodeMessageHeader* NodeRouteMessageResponse::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NodeRouteMessageResponse.header)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NodeMessageHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::NodeMessageHeader* NodeRouteMessageResponse::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NodeMessageHeader>(GetArena());
    _impl_.header_ = reinterpret_cast<::NodeMessageHeader*>(p);
  }
  return _impl_.header_;
}
inline ::NodeMessageHeader* NodeRouteMessageResponse::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::NodeMessageHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:NodeRouteMessageResponse.header)
  return _msg;
}
inline void NodeRouteMessageResponse::set_allocated_header(::NodeMessageHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.header_ = reinterpret_cast<::NodeMessageHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:NodeRouteMessageResponse.header)
}

// -------------------------------------------------------------------

// PlayerInfoExternal

// uint64 player_id = 1;
inline void PlayerInfoExternal::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_ = ::uint64_t{0u};
}
inline ::uint64_t PlayerInfoExternal::player_id() const {
  // @@protoc_insertion_point(field_get:PlayerInfoExternal.player_id)
  return _internal_player_id();
}
inline void PlayerInfoExternal::set_player_id(::uint64_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:PlayerInfoExternal.player_id)
}
inline ::uint64_t PlayerInfoExternal::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_;
}
inline void PlayerInfoExternal::_internal_set_player_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_ = value;
}

// -------------------------------------------------------------------

// PlayerNodeServiceRequest

// .MessageContent message_content = 1;
inline bool PlayerNodeServiceRequest::has_message_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.message_content_ != nullptr);
  return value;
}
inline void PlayerNodeServiceRequest::clear_message_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.message_content_ != nullptr) _impl_.message_content_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MessageContent& PlayerNodeServiceRequest::_internal_message_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::MessageContent* p = _impl_.message_content_;
  return p != nullptr ? *p : reinterpret_cast<const ::MessageContent&>(::_MessageContent_default_instance_);
}
inline const ::MessageContent& PlayerNodeServiceRequest::message_content() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PlayerNodeServiceRequest.message_content)
  return _internal_message_content();
}
inline void PlayerNodeServiceRequest::unsafe_arena_set_allocated_message_content(::MessageContent* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.message_content_);
  }
  _impl_.message_content_ = reinterpret_cast<::MessageContent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerNodeServiceRequest.message_content)
}
inline ::MessageContent* PlayerNodeServiceRequest::release_message_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MessageContent* released = _impl_.message_content_;
  _impl_.message_content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::MessageContent* PlayerNodeServiceRequest::unsafe_arena_release_message_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:PlayerNodeServiceRequest.message_content)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MessageContent* temp = _impl_.message_content_;
  _impl_.message_content_ = nullptr;
  return temp;
}
inline ::MessageContent* PlayerNodeServiceRequest::_internal_mutable_message_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.message_content_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::MessageContent>(GetArena());
    _impl_.message_content_ = reinterpret_cast<::MessageContent*>(p);
  }
  return _impl_.message_content_;
}
inline ::MessageContent* PlayerNodeServiceRequest::mutable_message_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::MessageContent* _msg = _internal_mutable_message_content();
  // @@protoc_insertion_point(field_mutable:PlayerNodeServiceRequest.message_content)
  return _msg;
}
inline void PlayerNodeServiceRequest::set_allocated_message_content(::MessageContent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.message_content_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.message_content_ = reinterpret_cast<::MessageContent*>(value);
  // @@protoc_insertion_point(field_set_allocated:PlayerNodeServiceRequest.message_content)
}

// .PlayerInfoExternal header = 2;
inline bool PlayerNodeServiceRequest::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void PlayerNodeServiceRequest::clear_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::PlayerInfoExternal& PlayerNodeServiceRequest::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::PlayerInfoExternal* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerInfoExternal&>(::_PlayerInfoExternal_default_instance_);
}
inline const ::PlayerInfoExternal& PlayerNodeServiceRequest::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PlayerNodeServiceRequest.header)
  return _internal_header();
}
inline void PlayerNodeServiceRequest::unsafe_arena_set_allocated_header(::PlayerInfoExternal* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::PlayerInfoExternal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerNodeServiceRequest.header)
}
inline ::PlayerInfoExternal* PlayerNodeServiceRequest::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PlayerInfoExternal* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::PlayerInfoExternal* PlayerNodeServiceRequest::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:PlayerNodeServiceRequest.header)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PlayerInfoExternal* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::PlayerInfoExternal* PlayerNodeServiceRequest::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::PlayerInfoExternal>(GetArena());
    _impl_.header_ = reinterpret_cast<::PlayerInfoExternal*>(p);
  }
  return _impl_.header_;
}
inline ::PlayerInfoExternal* PlayerNodeServiceRequest::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::PlayerInfoExternal* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:PlayerNodeServiceRequest.header)
  return _msg;
}
inline void PlayerNodeServiceRequest::set_allocated_header(::PlayerInfoExternal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.header_ = reinterpret_cast<::PlayerInfoExternal*>(value);
  // @@protoc_insertion_point(field_set_allocated:PlayerNodeServiceRequest.header)
}

// -------------------------------------------------------------------

// PlayerMessageResponse

// .MessageContent message_content = 1;
inline bool PlayerMessageResponse::has_message_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.message_content_ != nullptr);
  return value;
}
inline void PlayerMessageResponse::clear_message_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.message_content_ != nullptr) _impl_.message_content_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MessageContent& PlayerMessageResponse::_internal_message_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::MessageContent* p = _impl_.message_content_;
  return p != nullptr ? *p : reinterpret_cast<const ::MessageContent&>(::_MessageContent_default_instance_);
}
inline const ::MessageContent& PlayerMessageResponse::message_content() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PlayerMessageResponse.message_content)
  return _internal_message_content();
}
inline void PlayerMessageResponse::unsafe_arena_set_allocated_message_content(::MessageContent* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.message_content_);
  }
  _impl_.message_content_ = reinterpret_cast<::MessageContent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerMessageResponse.message_content)
}
inline ::MessageContent* PlayerMessageResponse::release_message_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MessageContent* released = _impl_.message_content_;
  _impl_.message_content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::MessageContent* PlayerMessageResponse::unsafe_arena_release_message_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:PlayerMessageResponse.message_content)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MessageContent* temp = _impl_.message_content_;
  _impl_.message_content_ = nullptr;
  return temp;
}
inline ::MessageContent* PlayerMessageResponse::_internal_mutable_message_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.message_content_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::MessageContent>(GetArena());
    _impl_.message_content_ = reinterpret_cast<::MessageContent*>(p);
  }
  return _impl_.message_content_;
}
inline ::MessageContent* PlayerMessageResponse::mutable_message_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::MessageContent* _msg = _internal_mutable_message_content();
  // @@protoc_insertion_point(field_mutable:PlayerMessageResponse.message_content)
  return _msg;
}
inline void PlayerMessageResponse::set_allocated_message_content(::MessageContent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.message_content_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.message_content_ = reinterpret_cast<::MessageContent*>(value);
  // @@protoc_insertion_point(field_set_allocated:PlayerMessageResponse.message_content)
}

// .PlayerInfoExternal header = 2;
inline bool PlayerMessageResponse::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void PlayerMessageResponse::clear_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::PlayerInfoExternal& PlayerMessageResponse::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::PlayerInfoExternal* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerInfoExternal&>(::_PlayerInfoExternal_default_instance_);
}
inline const ::PlayerInfoExternal& PlayerMessageResponse::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PlayerMessageResponse.header)
  return _internal_header();
}
inline void PlayerMessageResponse::unsafe_arena_set_allocated_header(::PlayerInfoExternal* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::PlayerInfoExternal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerMessageResponse.header)
}
inline ::PlayerInfoExternal* PlayerMessageResponse::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PlayerInfoExternal* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::PlayerInfoExternal* PlayerMessageResponse::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:PlayerMessageResponse.header)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PlayerInfoExternal* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::PlayerInfoExternal* PlayerMessageResponse::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::PlayerInfoExternal>(GetArena());
    _impl_.header_ = reinterpret_cast<::PlayerInfoExternal*>(p);
  }
  return _impl_.header_;
}
inline ::PlayerInfoExternal* PlayerMessageResponse::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::PlayerInfoExternal* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:PlayerMessageResponse.header)
  return _msg;
}
inline void PlayerMessageResponse::set_allocated_header(::PlayerInfoExternal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.header_ = reinterpret_cast<::PlayerInfoExternal*>(value);
  // @@protoc_insertion_point(field_set_allocated:PlayerMessageResponse.header)
}

// -------------------------------------------------------------------

// NodeRoutingMessageBody

// .NodeInfo node_info = 2;
inline bool NodeRoutingMessageBody::has_node_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.node_info_ != nullptr);
  return value;
}
inline const ::NodeInfo& NodeRoutingMessageBody::_internal_node_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NodeInfo* p = _impl_.node_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::NodeInfo&>(::_NodeInfo_default_instance_);
}
inline const ::NodeInfo& NodeRoutingMessageBody::node_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NodeRoutingMessageBody.node_info)
  return _internal_node_info();
}
inline void NodeRoutingMessageBody::unsafe_arena_set_allocated_node_info(::NodeInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_info_);
  }
  _impl_.node_info_ = reinterpret_cast<::NodeInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NodeRoutingMessageBody.node_info)
}
inline ::NodeInfo* NodeRoutingMessageBody::release_node_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NodeInfo* released = _impl_.node_info_;
  _impl_.node_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NodeInfo* NodeRoutingMessageBody::unsafe_arena_release_node_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NodeRoutingMessageBody.node_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NodeInfo* temp = _impl_.node_info_;
  _impl_.node_info_ = nullptr;
  return temp;
}
inline ::NodeInfo* NodeRoutingMessageBody::_internal_mutable_node_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.node_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NodeInfo>(GetArena());
    _impl_.node_info_ = reinterpret_cast<::NodeInfo*>(p);
  }
  return _impl_.node_info_;
}
inline ::NodeInfo* NodeRoutingMessageBody::mutable_node_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::NodeInfo* _msg = _internal_mutable_node_info();
  // @@protoc_insertion_point(field_mutable:NodeRoutingMessageBody.node_info)
  return _msg;
}
inline void NodeRoutingMessageBody::set_allocated_node_info(::NodeInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.node_info_ = reinterpret_cast<::NodeInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:NodeRoutingMessageBody.node_info)
}

// -------------------------------------------------------------------

// RegisterGameNodeSessionRequest

// .SessionDetails session_info = 1;
inline bool RegisterGameNodeSessionRequest::has_session_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.session_info_ != nullptr);
  return value;
}
inline const ::SessionDetails& RegisterGameNodeSessionRequest::_internal_session_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SessionDetails* p = _impl_.session_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionDetails&>(::_SessionDetails_default_instance_);
}
inline const ::SessionDetails& RegisterGameNodeSessionRequest::session_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterGameNodeSessionRequest.session_info)
  return _internal_session_info();
}
inline void RegisterGameNodeSessionRequest::unsafe_arena_set_allocated_session_info(::SessionDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }
  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterGameNodeSessionRequest.session_info)
}
inline ::SessionDetails* RegisterGameNodeSessionRequest::release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* released = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SessionDetails* RegisterGameNodeSessionRequest::unsafe_arena_release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RegisterGameNodeSessionRequest.session_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* temp = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
  return temp;
}
inline ::SessionDetails* RegisterGameNodeSessionRequest::_internal_mutable_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.session_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::SessionDetails>(GetArena());
    _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(p);
  }
  return _impl_.session_info_;
}
inline ::SessionDetails* RegisterGameNodeSessionRequest::mutable_session_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::SessionDetails* _msg = _internal_mutable_session_info();
  // @@protoc_insertion_point(field_mutable:RegisterGameNodeSessionRequest.session_info)
  return _msg;
}
inline void RegisterGameNodeSessionRequest::set_allocated_session_info(::SessionDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:RegisterGameNodeSessionRequest.session_info)
}

// uint32 game_node_id = 2;
inline void RegisterGameNodeSessionRequest::clear_scene_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_node_id_ = 0u;
}
inline ::uint32_t RegisterGameNodeSessionRequest::scene_node_id() const {
  // @@protoc_insertion_point(field_get:RegisterGameNodeSessionRequest.game_node_id)
  return _internal_scene_node_id();
}
inline void RegisterGameNodeSessionRequest::set_game_node_id(::uint32_t value) {
  _internal_set_game_node_id(value);
  // @@protoc_insertion_point(field_set:RegisterGameNodeSessionRequest.game_node_id)
}
inline ::uint32_t RegisterGameNodeSessionRequest::_internal_scene_node_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.game_node_id_;
}
inline void RegisterGameNodeSessionRequest::_internal_set_game_node_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_node_id_ = value;
}

// -------------------------------------------------------------------

// RegisterGameNodeSessionResponse

// .SessionDetails session_info = 1;
inline bool RegisterGameNodeSessionResponse::has_session_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.session_info_ != nullptr);
  return value;
}
inline const ::SessionDetails& RegisterGameNodeSessionResponse::_internal_session_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SessionDetails* p = _impl_.session_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionDetails&>(::_SessionDetails_default_instance_);
}
inline const ::SessionDetails& RegisterGameNodeSessionResponse::session_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterGameNodeSessionResponse.session_info)
  return _internal_session_info();
}
inline void RegisterGameNodeSessionResponse::unsafe_arena_set_allocated_session_info(::SessionDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }
  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterGameNodeSessionResponse.session_info)
}
inline ::SessionDetails* RegisterGameNodeSessionResponse::release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* released = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SessionDetails* RegisterGameNodeSessionResponse::unsafe_arena_release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RegisterGameNodeSessionResponse.session_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* temp = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
  return temp;
}
inline ::SessionDetails* RegisterGameNodeSessionResponse::_internal_mutable_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.session_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::SessionDetails>(GetArena());
    _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(p);
  }
  return _impl_.session_info_;
}
inline ::SessionDetails* RegisterGameNodeSessionResponse::mutable_session_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::SessionDetails* _msg = _internal_mutable_session_info();
  // @@protoc_insertion_point(field_mutable:RegisterGameNodeSessionResponse.session_info)
  return _msg;
}
inline void RegisterGameNodeSessionResponse::set_allocated_session_info(::SessionDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:RegisterGameNodeSessionResponse.session_info)
}

// -------------------------------------------------------------------

// RegisterGateNodeSessionResponse

// .SessionDetails session_info = 1;
inline bool RegisterGateNodeSessionResponse::has_session_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.session_info_ != nullptr);
  return value;
}
inline const ::SessionDetails& RegisterGateNodeSessionResponse::_internal_session_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SessionDetails* p = _impl_.session_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionDetails&>(::_SessionDetails_default_instance_);
}
inline const ::SessionDetails& RegisterGateNodeSessionResponse::session_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterGateNodeSessionResponse.session_info)
  return _internal_session_info();
}
inline void RegisterGateNodeSessionResponse::unsafe_arena_set_allocated_session_info(::SessionDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }
  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterGateNodeSessionResponse.session_info)
}
inline ::SessionDetails* RegisterGateNodeSessionResponse::release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* released = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SessionDetails* RegisterGateNodeSessionResponse::unsafe_arena_release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RegisterGateNodeSessionResponse.session_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* temp = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
  return temp;
}
inline ::SessionDetails* RegisterGateNodeSessionResponse::_internal_mutable_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.session_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::SessionDetails>(GetArena());
    _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(p);
  }
  return _impl_.session_info_;
}
inline ::SessionDetails* RegisterGateNodeSessionResponse::mutable_session_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::SessionDetails* _msg = _internal_mutable_session_info();
  // @@protoc_insertion_point(field_mutable:RegisterGateNodeSessionResponse.session_info)
  return _msg;
}
inline void RegisterGateNodeSessionResponse::set_allocated_session_info(::SessionDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:RegisterGateNodeSessionResponse.session_info)
}

// -------------------------------------------------------------------

// RegisterCentreSessionNodeRequest

// .SessionDetails session_info = 1;
inline bool RegisterCentreSessionNodeRequest::has_session_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.session_info_ != nullptr);
  return value;
}
inline const ::SessionDetails& RegisterCentreSessionNodeRequest::_internal_session_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SessionDetails* p = _impl_.session_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionDetails&>(::_SessionDetails_default_instance_);
}
inline const ::SessionDetails& RegisterCentreSessionNodeRequest::session_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterCentreSessionNodeRequest.session_info)
  return _internal_session_info();
}
inline void RegisterCentreSessionNodeRequest::unsafe_arena_set_allocated_session_info(::SessionDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }
  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterCentreSessionNodeRequest.session_info)
}
inline ::SessionDetails* RegisterCentreSessionNodeRequest::release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* released = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SessionDetails* RegisterCentreSessionNodeRequest::unsafe_arena_release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RegisterCentreSessionNodeRequest.session_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* temp = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
  return temp;
}
inline ::SessionDetails* RegisterCentreSessionNodeRequest::_internal_mutable_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.session_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::SessionDetails>(GetArena());
    _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(p);
  }
  return _impl_.session_info_;
}
inline ::SessionDetails* RegisterCentreSessionNodeRequest::mutable_session_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::SessionDetails* _msg = _internal_mutable_session_info();
  // @@protoc_insertion_point(field_mutable:RegisterCentreSessionNodeRequest.session_info)
  return _msg;
}
inline void RegisterCentreSessionNodeRequest::set_allocated_session_info(::SessionDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:RegisterCentreSessionNodeRequest.session_info)
}

// uint32 centre_node_id = 2;
inline void RegisterCentreSessionNodeRequest::clear_centre_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.centre_node_id_ = 0u;
}
inline ::uint32_t RegisterCentreSessionNodeRequest::centre_node_id() const {
  // @@protoc_insertion_point(field_get:RegisterCentreSessionNodeRequest.centre_node_id)
  return _internal_centre_node_id();
}
inline void RegisterCentreSessionNodeRequest::set_centre_node_id(::uint32_t value) {
  _internal_set_centre_node_id(value);
  // @@protoc_insertion_point(field_set:RegisterCentreSessionNodeRequest.centre_node_id)
}
inline ::uint32_t RegisterCentreSessionNodeRequest::_internal_centre_node_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.centre_node_id_;
}
inline void RegisterCentreSessionNodeRequest::_internal_set_centre_node_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.centre_node_id_ = value;
}

// -------------------------------------------------------------------

// RegisterSessionCentreNodeResponse

// .SessionDetails session_info = 1;
inline bool RegisterSessionCentreNodeResponse::has_session_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.session_info_ != nullptr);
  return value;
}
inline const ::SessionDetails& RegisterSessionCentreNodeResponse::_internal_session_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SessionDetails* p = _impl_.session_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionDetails&>(::_SessionDetails_default_instance_);
}
inline const ::SessionDetails& RegisterSessionCentreNodeResponse::session_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterSessionCentreNodeResponse.session_info)
  return _internal_session_info();
}
inline void RegisterSessionCentreNodeResponse::unsafe_arena_set_allocated_session_info(::SessionDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }
  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterSessionCentreNodeResponse.session_info)
}
inline ::SessionDetails* RegisterSessionCentreNodeResponse::release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* released = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SessionDetails* RegisterSessionCentreNodeResponse::unsafe_arena_release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RegisterSessionCentreNodeResponse.session_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* temp = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
  return temp;
}
inline ::SessionDetails* RegisterSessionCentreNodeResponse::_internal_mutable_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.session_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::SessionDetails>(GetArena());
    _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(p);
  }
  return _impl_.session_info_;
}
inline ::SessionDetails* RegisterSessionCentreNodeResponse::mutable_session_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::SessionDetails* _msg = _internal_mutable_session_info();
  // @@protoc_insertion_point(field_mutable:RegisterSessionCentreNodeResponse.session_info)
  return _msg;
}
inline void RegisterSessionCentreNodeResponse::set_allocated_session_info(::SessionDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:RegisterSessionCentreNodeResponse.session_info)
}

// -------------------------------------------------------------------

// GateSessionDisconnectRequest

// .SessionDetails session_info = 1;
inline bool GateSessionDisconnectRequest::has_session_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.session_info_ != nullptr);
  return value;
}
inline const ::SessionDetails& GateSessionDisconnectRequest::_internal_session_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SessionDetails* p = _impl_.session_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::SessionDetails&>(::_SessionDetails_default_instance_);
}
inline const ::SessionDetails& GateSessionDisconnectRequest::session_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GateSessionDisconnectRequest.session_info)
  return _internal_session_info();
}
inline void GateSessionDisconnectRequest::unsafe_arena_set_allocated_session_info(::SessionDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }
  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GateSessionDisconnectRequest.session_info)
}
inline ::SessionDetails* GateSessionDisconnectRequest::release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* released = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SessionDetails* GateSessionDisconnectRequest::unsafe_arena_release_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GateSessionDisconnectRequest.session_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SessionDetails* temp = _impl_.session_info_;
  _impl_.session_info_ = nullptr;
  return temp;
}
inline ::SessionDetails* GateSessionDisconnectRequest::_internal_mutable_session_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.session_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::SessionDetails>(GetArena());
    _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(p);
  }
  return _impl_.session_info_;
}
inline ::SessionDetails* GateSessionDisconnectRequest::mutable_session_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::SessionDetails* _msg = _internal_mutable_session_info();
  // @@protoc_insertion_point(field_mutable:GateSessionDisconnectRequest.session_info)
  return _msg;
}
inline void GateSessionDisconnectRequest::set_allocated_session_info(::SessionDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.session_info_ = reinterpret_cast<::SessionDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:GateSessionDisconnectRequest.session_info)
}

// -------------------------------------------------------------------

// RouteMessageRequest

// bytes body = 1;
inline void RouteMessageRequest::clear_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.ClearToEmpty();
}
inline const std::string& RouteMessageRequest::body() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RouteMessageRequest.body)
  return _internal_body();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouteMessageRequest::set_body(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RouteMessageRequest.body)
}
inline std::string* RouteMessageRequest::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:RouteMessageRequest.body)
  return _s;
}
inline const std::string& RouteMessageRequest::_internal_body() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.body_.Get();
}
inline void RouteMessageRequest::_internal_set_body(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.Set(value, GetArena());
}
inline std::string* RouteMessageRequest::_internal_mutable_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.body_.Mutable( GetArena());
}
inline std::string* RouteMessageRequest::release_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RouteMessageRequest.body)
  return _impl_.body_.Release();
}
inline void RouteMessageRequest::set_allocated_body(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.body_.IsDefault()) {
          _impl_.body_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RouteMessageRequest.body)
}

// repeated .RoutingNodeInfo route_nodes = 2;
inline int RouteMessageRequest::_internal_route_nodes_size() const {
  return _internal_route_nodes().size();
}
inline int RouteMessageRequest::route_nodes_size() const {
  return _internal_route_nodes_size();
}
inline void RouteMessageRequest::clear_route_nodes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.route_nodes_.Clear();
}
inline ::RoutingNodeInfo* RouteMessageRequest::mutable_route_nodes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:RouteMessageRequest.route_nodes)
  return _internal_mutable_route_nodes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::RoutingNodeInfo>* RouteMessageRequest::mutable_route_nodes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:RouteMessageRequest.route_nodes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_route_nodes();
}
inline const ::RoutingNodeInfo& RouteMessageRequest::route_nodes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RouteMessageRequest.route_nodes)
  return _internal_route_nodes().Get(index);
}
inline ::RoutingNodeInfo* RouteMessageRequest::add_route_nodes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::RoutingNodeInfo* _add = _internal_mutable_route_nodes()->Add();
  // @@protoc_insertion_point(field_add:RouteMessageRequest.route_nodes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::RoutingNodeInfo>& RouteMessageRequest::route_nodes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:RouteMessageRequest.route_nodes)
  return _internal_route_nodes();
}
inline const ::google::protobuf::RepeatedPtrField<::RoutingNodeInfo>&
RouteMessageRequest::_internal_route_nodes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.route_nodes_;
}
inline ::google::protobuf::RepeatedPtrField<::RoutingNodeInfo>*
RouteMessageRequest::_internal_mutable_route_nodes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.route_nodes_;
}

// uint64 session_id = 3;
inline void RouteMessageRequest::clear_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_ = ::uint64_t{0u};
}
inline ::uint64_t RouteMessageRequest::session_id() const {
  // @@protoc_insertion_point(field_get:RouteMessageRequest.session_id)
  return _internal_session_id();
}
inline void RouteMessageRequest::set_session_id(::uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:RouteMessageRequest.session_id)
}
inline ::uint64_t RouteMessageRequest::_internal_session_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.session_id_;
}
inline void RouteMessageRequest::_internal_set_session_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_ = value;
}

// uint64 id = 4;
inline void RouteMessageRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t RouteMessageRequest::id() const {
  // @@protoc_insertion_point(field_get:RouteMessageRequest.id)
  return _internal_id();
}
inline void RouteMessageRequest::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:RouteMessageRequest.id)
}
inline ::uint64_t RouteMessageRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void RouteMessageRequest::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = value;
}

// bool is_client = 5;
inline void RouteMessageRequest::clear_is_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_client_ = false;
}
inline bool RouteMessageRequest::is_client() const {
  // @@protoc_insertion_point(field_get:RouteMessageRequest.is_client)
  return _internal_is_client();
}
inline void RouteMessageRequest::set_is_client(bool value) {
  _internal_set_is_client(value);
  // @@protoc_insertion_point(field_set:RouteMessageRequest.is_client)
}
inline bool RouteMessageRequest::_internal_is_client() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_client_;
}
inline void RouteMessageRequest::_internal_set_is_client(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_client_ = value;
}

// -------------------------------------------------------------------

// RouteMessageResponse

// bytes body = 1;
inline void RouteMessageResponse::clear_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.ClearToEmpty();
}
inline const std::string& RouteMessageResponse::body() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RouteMessageResponse.body)
  return _internal_body();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouteMessageResponse::set_body(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RouteMessageResponse.body)
}
inline std::string* RouteMessageResponse::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:RouteMessageResponse.body)
  return _s;
}
inline const std::string& RouteMessageResponse::_internal_body() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.body_.Get();
}
inline void RouteMessageResponse::_internal_set_body(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.Set(value, GetArena());
}
inline std::string* RouteMessageResponse::_internal_mutable_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.body_.Mutable( GetArena());
}
inline std::string* RouteMessageResponse::release_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RouteMessageResponse.body)
  return _impl_.body_.Release();
}
inline void RouteMessageResponse::set_allocated_body(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.body_.IsDefault()) {
          _impl_.body_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RouteMessageResponse.body)
}

// repeated .RoutingNodeInfo route_nodes = 2;
inline int RouteMessageResponse::_internal_route_nodes_size() const {
  return _internal_route_nodes().size();
}
inline int RouteMessageResponse::route_nodes_size() const {
  return _internal_route_nodes_size();
}
inline void RouteMessageResponse::clear_route_nodes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.route_nodes_.Clear();
}
inline ::RoutingNodeInfo* RouteMessageResponse::mutable_route_nodes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:RouteMessageResponse.route_nodes)
  return _internal_mutable_route_nodes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::RoutingNodeInfo>* RouteMessageResponse::mutable_route_nodes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:RouteMessageResponse.route_nodes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_route_nodes();
}
inline const ::RoutingNodeInfo& RouteMessageResponse::route_nodes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RouteMessageResponse.route_nodes)
  return _internal_route_nodes().Get(index);
}
inline ::RoutingNodeInfo* RouteMessageResponse::add_route_nodes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::RoutingNodeInfo* _add = _internal_mutable_route_nodes()->Add();
  // @@protoc_insertion_point(field_add:RouteMessageResponse.route_nodes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::RoutingNodeInfo>& RouteMessageResponse::route_nodes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:RouteMessageResponse.route_nodes)
  return _internal_route_nodes();
}
inline const ::google::protobuf::RepeatedPtrField<::RoutingNodeInfo>&
RouteMessageResponse::_internal_route_nodes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.route_nodes_;
}
inline ::google::protobuf::RepeatedPtrField<::RoutingNodeInfo>*
RouteMessageResponse::_internal_mutable_route_nodes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.route_nodes_;
}

// uint64 session_id = 3;
inline void RouteMessageResponse::clear_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_ = ::uint64_t{0u};
}
inline ::uint64_t RouteMessageResponse::session_id() const {
  // @@protoc_insertion_point(field_get:RouteMessageResponse.session_id)
  return _internal_session_id();
}
inline void RouteMessageResponse::set_session_id(::uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:RouteMessageResponse.session_id)
}
inline ::uint64_t RouteMessageResponse::_internal_session_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.session_id_;
}
inline void RouteMessageResponse::_internal_set_session_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_ = value;
}

// uint64 id = 4;
inline void RouteMessageResponse::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t RouteMessageResponse::id() const {
  // @@protoc_insertion_point(field_get:RouteMessageResponse.id)
  return _internal_id();
}
inline void RouteMessageResponse::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:RouteMessageResponse.id)
}
inline ::uint64_t RouteMessageResponse::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void RouteMessageResponse::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = value;
}

// bool is_client = 5;
inline void RouteMessageResponse::clear_is_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_client_ = false;
}
inline bool RouteMessageResponse::is_client() const {
  // @@protoc_insertion_point(field_get:RouteMessageResponse.is_client)
  return _internal_is_client();
}
inline void RouteMessageResponse::set_is_client(bool value) {
  _internal_set_is_client(value);
  // @@protoc_insertion_point(field_set:RouteMessageResponse.is_client)
}
inline bool RouteMessageResponse::_internal_is_client() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_client_;
}
inline void RouteMessageResponse::_internal_set_is_client(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_client_ = value;
}

// -------------------------------------------------------------------

// RoutePlayerMessageRequest

// bytes body = 1;
inline void RoutePlayerMessageRequest::clear_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.ClearToEmpty();
}
inline const std::string& RoutePlayerMessageRequest::body() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RoutePlayerMessageRequest.body)
  return _internal_body();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RoutePlayerMessageRequest::set_body(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RoutePlayerMessageRequest.body)
}
inline std::string* RoutePlayerMessageRequest::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:RoutePlayerMessageRequest.body)
  return _s;
}
inline const std::string& RoutePlayerMessageRequest::_internal_body() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.body_.Get();
}
inline void RoutePlayerMessageRequest::_internal_set_body(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.Set(value, GetArena());
}
inline std::string* RoutePlayerMessageRequest::_internal_mutable_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.body_.Mutable( GetArena());
}
inline std::string* RoutePlayerMessageRequest::release_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RoutePlayerMessageRequest.body)
  return _impl_.body_.Release();
}
inline void RoutePlayerMessageRequest::set_allocated_body(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.body_.IsDefault()) {
          _impl_.body_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RoutePlayerMessageRequest.body)
}

// repeated .NodeInfo node_list = 2;
inline int RoutePlayerMessageRequest::_internal_node_list_size() const {
  return _internal_node_list().size();
}
inline int RoutePlayerMessageRequest::node_list_size() const {
  return _internal_node_list_size();
}
inline ::NodeInfo* RoutePlayerMessageRequest::mutable_node_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:RoutePlayerMessageRequest.node_list)
  return _internal_mutable_node_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::NodeInfo>* RoutePlayerMessageRequest::mutable_node_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:RoutePlayerMessageRequest.node_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_node_list();
}
inline const ::NodeInfo& RoutePlayerMessageRequest::node_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RoutePlayerMessageRequest.node_list)
  return _internal_node_list().Get(index);
}
inline ::NodeInfo* RoutePlayerMessageRequest::add_node_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NodeInfo* _add = _internal_mutable_node_list()->Add();
  // @@protoc_insertion_point(field_add:RoutePlayerMessageRequest.node_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::NodeInfo>& RoutePlayerMessageRequest::node_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:RoutePlayerMessageRequest.node_list)
  return _internal_node_list();
}
inline const ::google::protobuf::RepeatedPtrField<::NodeInfo>&
RoutePlayerMessageRequest::_internal_node_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_list_;
}
inline ::google::protobuf::RepeatedPtrField<::NodeInfo>*
RoutePlayerMessageRequest::_internal_mutable_node_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.node_list_;
}

// .PlayerInfoExternal player_info = 3;
inline bool RoutePlayerMessageRequest::has_player_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_info_ != nullptr);
  return value;
}
inline void RoutePlayerMessageRequest::clear_player_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_info_ != nullptr) _impl_.player_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::PlayerInfoExternal& RoutePlayerMessageRequest::_internal_player_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::PlayerInfoExternal* p = _impl_.player_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerInfoExternal&>(::_PlayerInfoExternal_default_instance_);
}
inline const ::PlayerInfoExternal& RoutePlayerMessageRequest::player_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RoutePlayerMessageRequest.player_info)
  return _internal_player_info();
}
inline void RoutePlayerMessageRequest::unsafe_arena_set_allocated_player_info(::PlayerInfoExternal* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_info_);
  }
  _impl_.player_info_ = reinterpret_cast<::PlayerInfoExternal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoutePlayerMessageRequest.player_info)
}
inline ::PlayerInfoExternal* RoutePlayerMessageRequest::release_player_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PlayerInfoExternal* released = _impl_.player_info_;
  _impl_.player_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::PlayerInfoExternal* RoutePlayerMessageRequest::unsafe_arena_release_player_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RoutePlayerMessageRequest.player_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PlayerInfoExternal* temp = _impl_.player_info_;
  _impl_.player_info_ = nullptr;
  return temp;
}
inline ::PlayerInfoExternal* RoutePlayerMessageRequest::_internal_mutable_player_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::PlayerInfoExternal>(GetArena());
    _impl_.player_info_ = reinterpret_cast<::PlayerInfoExternal*>(p);
  }
  return _impl_.player_info_;
}
inline ::PlayerInfoExternal* RoutePlayerMessageRequest::mutable_player_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::PlayerInfoExternal* _msg = _internal_mutable_player_info();
  // @@protoc_insertion_point(field_mutable:RoutePlayerMessageRequest.player_info)
  return _msg;
}
inline void RoutePlayerMessageRequest::set_allocated_player_info(::PlayerInfoExternal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.player_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_info_ = reinterpret_cast<::PlayerInfoExternal*>(value);
  // @@protoc_insertion_point(field_set_allocated:RoutePlayerMessageRequest.player_info)
}

// -------------------------------------------------------------------

// RoutePlayerMessageResponse

// bytes body = 1;
inline void RoutePlayerMessageResponse::clear_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.ClearToEmpty();
}
inline const std::string& RoutePlayerMessageResponse::body() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RoutePlayerMessageResponse.body)
  return _internal_body();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RoutePlayerMessageResponse::set_body(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RoutePlayerMessageResponse.body)
}
inline std::string* RoutePlayerMessageResponse::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:RoutePlayerMessageResponse.body)
  return _s;
}
inline const std::string& RoutePlayerMessageResponse::_internal_body() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.body_.Get();
}
inline void RoutePlayerMessageResponse::_internal_set_body(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.Set(value, GetArena());
}
inline std::string* RoutePlayerMessageResponse::_internal_mutable_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.body_.Mutable( GetArena());
}
inline std::string* RoutePlayerMessageResponse::release_body() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RoutePlayerMessageResponse.body)
  return _impl_.body_.Release();
}
inline void RoutePlayerMessageResponse::set_allocated_body(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.body_.IsDefault()) {
          _impl_.body_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RoutePlayerMessageResponse.body)
}

// repeated .NodeInfo node_list = 2;
inline int RoutePlayerMessageResponse::_internal_node_list_size() const {
  return _internal_node_list().size();
}
inline int RoutePlayerMessageResponse::node_list_size() const {
  return _internal_node_list_size();
}
inline ::NodeInfo* RoutePlayerMessageResponse::mutable_node_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:RoutePlayerMessageResponse.node_list)
  return _internal_mutable_node_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::NodeInfo>* RoutePlayerMessageResponse::mutable_node_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:RoutePlayerMessageResponse.node_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_node_list();
}
inline const ::NodeInfo& RoutePlayerMessageResponse::node_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RoutePlayerMessageResponse.node_list)
  return _internal_node_list().Get(index);
}
inline ::NodeInfo* RoutePlayerMessageResponse::add_node_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NodeInfo* _add = _internal_mutable_node_list()->Add();
  // @@protoc_insertion_point(field_add:RoutePlayerMessageResponse.node_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::NodeInfo>& RoutePlayerMessageResponse::node_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:RoutePlayerMessageResponse.node_list)
  return _internal_node_list();
}
inline const ::google::protobuf::RepeatedPtrField<::NodeInfo>&
RoutePlayerMessageResponse::_internal_node_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_list_;
}
inline ::google::protobuf::RepeatedPtrField<::NodeInfo>*
RoutePlayerMessageResponse::_internal_mutable_node_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.node_list_;
}

// .PlayerInfoExternal player_info = 3;
inline bool RoutePlayerMessageResponse::has_player_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_info_ != nullptr);
  return value;
}
inline void RoutePlayerMessageResponse::clear_player_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_info_ != nullptr) _impl_.player_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::PlayerInfoExternal& RoutePlayerMessageResponse::_internal_player_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::PlayerInfoExternal* p = _impl_.player_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerInfoExternal&>(::_PlayerInfoExternal_default_instance_);
}
inline const ::PlayerInfoExternal& RoutePlayerMessageResponse::player_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RoutePlayerMessageResponse.player_info)
  return _internal_player_info();
}
inline void RoutePlayerMessageResponse::unsafe_arena_set_allocated_player_info(::PlayerInfoExternal* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_info_);
  }
  _impl_.player_info_ = reinterpret_cast<::PlayerInfoExternal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RoutePlayerMessageResponse.player_info)
}
inline ::PlayerInfoExternal* RoutePlayerMessageResponse::release_player_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PlayerInfoExternal* released = _impl_.player_info_;
  _impl_.player_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::PlayerInfoExternal* RoutePlayerMessageResponse::unsafe_arena_release_player_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RoutePlayerMessageResponse.player_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PlayerInfoExternal* temp = _impl_.player_info_;
  _impl_.player_info_ = nullptr;
  return temp;
}
inline ::PlayerInfoExternal* RoutePlayerMessageResponse::_internal_mutable_player_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::PlayerInfoExternal>(GetArena());
    _impl_.player_info_ = reinterpret_cast<::PlayerInfoExternal*>(p);
  }
  return _impl_.player_info_;
}
inline ::PlayerInfoExternal* RoutePlayerMessageResponse::mutable_player_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::PlayerInfoExternal* _msg = _internal_mutable_player_info();
  // @@protoc_insertion_point(field_mutable:RoutePlayerMessageResponse.player_info)
  return _msg;
}
inline void RoutePlayerMessageResponse::set_allocated_player_info(::PlayerInfoExternal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.player_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_info_ = reinterpret_cast<::PlayerInfoExternal*>(value);
  // @@protoc_insertion_point(field_set_allocated:RoutePlayerMessageResponse.player_info)
}

// -------------------------------------------------------------------

// RegisterGameNodeRequest

// .NetworkAddress rpc_client = 1;
inline bool RegisterGameNodeRequest::has_rpc_client() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rpc_client_ != nullptr);
  return value;
}
inline const ::NetworkAddress& RegisterGameNodeRequest::_internal_rpc_client() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NetworkAddress* p = _impl_.rpc_client_;
  return p != nullptr ? *p : reinterpret_cast<const ::NetworkAddress&>(::_NetworkAddress_default_instance_);
}
inline const ::NetworkAddress& RegisterGameNodeRequest::rpc_client() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterGameNodeRequest.rpc_client)
  return _internal_rpc_client();
}
inline void RegisterGameNodeRequest::unsafe_arena_set_allocated_rpc_client(::NetworkAddress* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_client_);
  }
  _impl_.rpc_client_ = reinterpret_cast<::NetworkAddress*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterGameNodeRequest.rpc_client)
}
inline ::NetworkAddress* RegisterGameNodeRequest::release_rpc_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NetworkAddress* released = _impl_.rpc_client_;
  _impl_.rpc_client_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NetworkAddress* RegisterGameNodeRequest::unsafe_arena_release_rpc_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RegisterGameNodeRequest.rpc_client)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NetworkAddress* temp = _impl_.rpc_client_;
  _impl_.rpc_client_ = nullptr;
  return temp;
}
inline ::NetworkAddress* RegisterGameNodeRequest::_internal_mutable_rpc_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rpc_client_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NetworkAddress>(GetArena());
    _impl_.rpc_client_ = reinterpret_cast<::NetworkAddress*>(p);
  }
  return _impl_.rpc_client_;
}
inline ::NetworkAddress* RegisterGameNodeRequest::mutable_rpc_client() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::NetworkAddress* _msg = _internal_mutable_rpc_client();
  // @@protoc_insertion_point(field_mutable:RegisterGameNodeRequest.rpc_client)
  return _msg;
}
inline void RegisterGameNodeRequest::set_allocated_rpc_client(::NetworkAddress* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_client_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.rpc_client_ = reinterpret_cast<::NetworkAddress*>(value);
  // @@protoc_insertion_point(field_set_allocated:RegisterGameNodeRequest.rpc_client)
}

// .NetworkAddress rpc_server = 2;
inline bool RegisterGameNodeRequest::has_rpc_server() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rpc_server_ != nullptr);
  return value;
}
inline const ::NetworkAddress& RegisterGameNodeRequest::_internal_rpc_server() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NetworkAddress* p = _impl_.rpc_server_;
  return p != nullptr ? *p : reinterpret_cast<const ::NetworkAddress&>(::_NetworkAddress_default_instance_);
}
inline const ::NetworkAddress& RegisterGameNodeRequest::rpc_server() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterGameNodeRequest.rpc_server)
  return _internal_rpc_server();
}
inline void RegisterGameNodeRequest::unsafe_arena_set_allocated_rpc_server(::NetworkAddress* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_server_);
  }
  _impl_.rpc_server_ = reinterpret_cast<::NetworkAddress*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterGameNodeRequest.rpc_server)
}
inline ::NetworkAddress* RegisterGameNodeRequest::release_rpc_server() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NetworkAddress* released = _impl_.rpc_server_;
  _impl_.rpc_server_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NetworkAddress* RegisterGameNodeRequest::unsafe_arena_release_rpc_server() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RegisterGameNodeRequest.rpc_server)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NetworkAddress* temp = _impl_.rpc_server_;
  _impl_.rpc_server_ = nullptr;
  return temp;
}
inline ::NetworkAddress* RegisterGameNodeRequest::_internal_mutable_rpc_server() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rpc_server_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NetworkAddress>(GetArena());
    _impl_.rpc_server_ = reinterpret_cast<::NetworkAddress*>(p);
  }
  return _impl_.rpc_server_;
}
inline ::NetworkAddress* RegisterGameNodeRequest::mutable_rpc_server() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::NetworkAddress* _msg = _internal_mutable_rpc_server();
  // @@protoc_insertion_point(field_mutable:RegisterGameNodeRequest.rpc_server)
  return _msg;
}
inline void RegisterGameNodeRequest::set_allocated_rpc_server(::NetworkAddress* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_server_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rpc_server_ = reinterpret_cast<::NetworkAddress*>(value);
  // @@protoc_insertion_point(field_set_allocated:RegisterGameNodeRequest.rpc_server)
}

// uint32 scene_node_id = 3;
inline void RegisterGameNodeRequest::clear_scene_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scene_node_id_ = 0u;
}
inline ::uint32_t RegisterGameNodeRequest::scene_node_id() const {
  // @@protoc_insertion_point(field_get:RegisterGameNodeRequest.scene_node_id)
  return _internal_scene_node_id();
}
inline void RegisterGameNodeRequest::set_scene_node_id(::uint32_t value) {
  _internal_set_scene_node_id(value);
  // @@protoc_insertion_point(field_set:RegisterGameNodeRequest.scene_node_id)
}
inline ::uint32_t RegisterGameNodeRequest::_internal_scene_node_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scene_node_id_;
}
inline void RegisterGameNodeRequest::_internal_set_scene_node_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scene_node_id_ = value;
}

// uint32 server_type = 4;
inline void RegisterGameNodeRequest::clear_server_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.server_type_ = 0u;
}
inline ::uint32_t RegisterGameNodeRequest::server_type() const {
  // @@protoc_insertion_point(field_get:RegisterGameNodeRequest.server_type)
  return _internal_server_type();
}
inline void RegisterGameNodeRequest::set_server_type(::uint32_t value) {
  _internal_set_server_type(value);
  // @@protoc_insertion_point(field_set:RegisterGameNodeRequest.server_type)
}
inline ::uint32_t RegisterGameNodeRequest::_internal_server_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.server_type_;
}
inline void RegisterGameNodeRequest::_internal_set_server_type(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.server_type_ = value;
}

// uint32 scene_node_type = 5;
inline void RegisterGameNodeRequest::clear_scene_node_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scene_node_type_ = 0u;
}
inline ::uint32_t RegisterGameNodeRequest::scene_node_type() const {
  // @@protoc_insertion_point(field_get:RegisterGameNodeRequest.scene_node_type)
  return _internal_scene_node_type();
}
inline void RegisterGameNodeRequest::set_scene_node_type(::uint32_t value) {
  _internal_set_scene_node_type(value);
  // @@protoc_insertion_point(field_set:RegisterGameNodeRequest.scene_node_type)
}
inline ::uint32_t RegisterGameNodeRequest::_internal_scene_node_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scene_node_type_;
}
inline void RegisterGameNodeRequest::_internal_set_scene_node_type(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scene_node_type_ = value;
}

// -------------------------------------------------------------------

// RegisterGateNodeRequest

// .NetworkAddress rpc_client = 1;
inline bool RegisterGateNodeRequest::has_rpc_client() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rpc_client_ != nullptr);
  return value;
}
inline const ::NetworkAddress& RegisterGateNodeRequest::_internal_rpc_client() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::NetworkAddress* p = _impl_.rpc_client_;
  return p != nullptr ? *p : reinterpret_cast<const ::NetworkAddress&>(::_NetworkAddress_default_instance_);
}
inline const ::NetworkAddress& RegisterGateNodeRequest::rpc_client() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RegisterGateNodeRequest.rpc_client)
  return _internal_rpc_client();
}
inline void RegisterGateNodeRequest::unsafe_arena_set_allocated_rpc_client(::NetworkAddress* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_client_);
  }
  _impl_.rpc_client_ = reinterpret_cast<::NetworkAddress*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterGateNodeRequest.rpc_client)
}
inline ::NetworkAddress* RegisterGateNodeRequest::release_rpc_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NetworkAddress* released = _impl_.rpc_client_;
  _impl_.rpc_client_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::NetworkAddress* RegisterGateNodeRequest::unsafe_arena_release_rpc_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RegisterGateNodeRequest.rpc_client)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NetworkAddress* temp = _impl_.rpc_client_;
  _impl_.rpc_client_ = nullptr;
  return temp;
}
inline ::NetworkAddress* RegisterGateNodeRequest::_internal_mutable_rpc_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rpc_client_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::NetworkAddress>(GetArena());
    _impl_.rpc_client_ = reinterpret_cast<::NetworkAddress*>(p);
  }
  return _impl_.rpc_client_;
}
inline ::NetworkAddress* RegisterGateNodeRequest::mutable_rpc_client() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::NetworkAddress* _msg = _internal_mutable_rpc_client();
  // @@protoc_insertion_point(field_mutable:RegisterGateNodeRequest.rpc_client)
  return _msg;
}
inline void RegisterGateNodeRequest::set_allocated_rpc_client(::NetworkAddress* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_client_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.rpc_client_ = reinterpret_cast<::NetworkAddress*>(value);
  // @@protoc_insertion_point(field_set_allocated:RegisterGateNodeRequest.rpc_client)
}

// uint32 gate_node_id = 2;
inline void RegisterGateNodeRequest::clear_gate_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gate_node_id_ = 0u;
}
inline ::uint32_t RegisterGateNodeRequest::gate_node_id() const {
  // @@protoc_insertion_point(field_get:RegisterGateNodeRequest.gate_node_id)
  return _internal_gate_node_id();
}
inline void RegisterGateNodeRequest::set_gate_node_id(::uint32_t value) {
  _internal_set_gate_node_id(value);
  // @@protoc_insertion_point(field_set:RegisterGateNodeRequest.gate_node_id)
}
inline ::uint32_t RegisterGateNodeRequest::_internal_gate_node_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gate_node_id_;
}
inline void RegisterGateNodeRequest::_internal_set_gate_node_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gate_node_id_ = value;
}

// -------------------------------------------------------------------

// UnregisterGameNodeRequest

// uint32 game_node_id = 1;
inline void UnregisterGameNodeRequest::clear_scene_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_node_id_ = 0u;
}
inline ::uint32_t UnregisterGameNodeRequest::scene_node_id() const {
  // @@protoc_insertion_point(field_get:UnregisterGameNodeRequest.game_node_id)
  return _internal_scene_node_id();
}
inline void UnregisterGameNodeRequest::set_game_node_id(::uint32_t value) {
  _internal_set_game_node_id(value);
  // @@protoc_insertion_point(field_set:UnregisterGameNodeRequest.game_node_id)
}
inline ::uint32_t UnregisterGameNodeRequest::_internal_scene_node_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.game_node_id_;
}
inline void UnregisterGameNodeRequest::_internal_set_game_node_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_node_id_ = value;
}

// -------------------------------------------------------------------

// ProtoFieldCheckerTestSubPB

// repeated string items = 1;
inline int ProtoFieldCheckerTestSubPB::_internal_items_size() const {
  return _internal_items().size();
}
inline int ProtoFieldCheckerTestSubPB::items_size() const {
  return _internal_items_size();
}
inline void ProtoFieldCheckerTestSubPB::clear_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.items_.Clear();
}
inline std::string* ProtoFieldCheckerTestSubPB::add_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add_mutable:ProtoFieldCheckerTestSubPB.items)
  return _s;
}
inline const std::string& ProtoFieldCheckerTestSubPB::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ProtoFieldCheckerTestSubPB.items)
  return _internal_items().Get(index);
}
inline std::string* ProtoFieldCheckerTestSubPB::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ProtoFieldCheckerTestSubPB.items)
  return _internal_mutable_items()->Mutable(index);
}
inline void ProtoFieldCheckerTestSubPB::set_items(int index, const std::string& value) {
  _internal_mutable_items()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ProtoFieldCheckerTestSubPB.items)
}
inline void ProtoFieldCheckerTestSubPB::set_items(int index, std::string&& value) {
  _internal_mutable_items()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ProtoFieldCheckerTestSubPB.items)
}
inline void ProtoFieldCheckerTestSubPB::set_items(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_items()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ProtoFieldCheckerTestSubPB.items)
}
inline void ProtoFieldCheckerTestSubPB::set_items(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_items()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProtoFieldCheckerTestSubPB.items)
}
inline void ProtoFieldCheckerTestSubPB::set_items(int index, absl::string_view value) {
  _internal_mutable_items()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:ProtoFieldCheckerTestSubPB.items)
}
inline void ProtoFieldCheckerTestSubPB::add_items(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ProtoFieldCheckerTestSubPB.items)
}
inline void ProtoFieldCheckerTestSubPB::add_items(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ProtoFieldCheckerTestSubPB.items)
}
inline void ProtoFieldCheckerTestSubPB::add_items(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ProtoFieldCheckerTestSubPB.items)
}
inline void ProtoFieldCheckerTestSubPB::add_items(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ProtoFieldCheckerTestSubPB.items)
}
inline void ProtoFieldCheckerTestSubPB::add_items(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_items()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:ProtoFieldCheckerTestSubPB.items)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProtoFieldCheckerTestSubPB::items() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ProtoFieldCheckerTestSubPB.items)
  return _internal_items();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProtoFieldCheckerTestSubPB::mutable_items() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ProtoFieldCheckerTestSubPB.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProtoFieldCheckerTestSubPB::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProtoFieldCheckerTestSubPB::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// -------------------------------------------------------------------

// ProtoFieldCheckerTestPB

// .ProtoFieldCheckerTestSubPB sub_message = 1;
inline bool ProtoFieldCheckerTestPB::has_sub_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sub_message_ != nullptr);
  return value;
}
inline void ProtoFieldCheckerTestPB::clear_sub_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.sub_message_ != nullptr) _impl_.sub_message_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ProtoFieldCheckerTestSubPB& ProtoFieldCheckerTestPB::_internal_sub_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ProtoFieldCheckerTestSubPB* p = _impl_.sub_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoFieldCheckerTestSubPB&>(::_ProtoFieldCheckerTestSubPB_default_instance_);
}
inline const ::ProtoFieldCheckerTestSubPB& ProtoFieldCheckerTestPB::sub_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ProtoFieldCheckerTestPB.sub_message)
  return _internal_sub_message();
}
inline void ProtoFieldCheckerTestPB::unsafe_arena_set_allocated_sub_message(::ProtoFieldCheckerTestSubPB* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sub_message_);
  }
  _impl_.sub_message_ = reinterpret_cast<::ProtoFieldCheckerTestSubPB*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoFieldCheckerTestPB.sub_message)
}
inline ::ProtoFieldCheckerTestSubPB* ProtoFieldCheckerTestPB::release_sub_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ProtoFieldCheckerTestSubPB* released = _impl_.sub_message_;
  _impl_.sub_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ProtoFieldCheckerTestSubPB* ProtoFieldCheckerTestPB::unsafe_arena_release_sub_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProtoFieldCheckerTestPB.sub_message)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ProtoFieldCheckerTestSubPB* temp = _impl_.sub_message_;
  _impl_.sub_message_ = nullptr;
  return temp;
}
inline ::ProtoFieldCheckerTestSubPB* ProtoFieldCheckerTestPB::_internal_mutable_sub_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.sub_message_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ProtoFieldCheckerTestSubPB>(GetArena());
    _impl_.sub_message_ = reinterpret_cast<::ProtoFieldCheckerTestSubPB*>(p);
  }
  return _impl_.sub_message_;
}
inline ::ProtoFieldCheckerTestSubPB* ProtoFieldCheckerTestPB::mutable_sub_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::ProtoFieldCheckerTestSubPB* _msg = _internal_mutable_sub_message();
  // @@protoc_insertion_point(field_mutable:ProtoFieldCheckerTestPB.sub_message)
  return _msg;
}
inline void ProtoFieldCheckerTestPB::set_allocated_sub_message(::ProtoFieldCheckerTestSubPB* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.sub_message_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.sub_message_ = reinterpret_cast<::ProtoFieldCheckerTestSubPB*>(value);
  // @@protoc_insertion_point(field_set_allocated:ProtoFieldCheckerTestPB.sub_message)
}

// -------------------------------------------------------------------

// MyProtoMessage

// int32 single_int32_field = 1;
inline void MyProtoMessage::clear_single_int32_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.single_int32_field_ = 0;
}
inline ::int32_t MyProtoMessage::single_int32_field() const {
  // @@protoc_insertion_point(field_get:MyProtoMessage.single_int32_field)
  return _internal_single_int32_field();
}
inline void MyProtoMessage::set_single_int32_field(::int32_t value) {
  _internal_set_single_int32_field(value);
  // @@protoc_insertion_point(field_set:MyProtoMessage.single_int32_field)
}
inline ::int32_t MyProtoMessage::_internal_single_int32_field() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.single_int32_field_;
}
inline void MyProtoMessage::_internal_set_single_int32_field(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.single_int32_field_ = value;
}

// int64 single_int64_field = 2;
inline void MyProtoMessage::clear_single_int64_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.single_int64_field_ = ::int64_t{0};
}
inline ::int64_t MyProtoMessage::single_int64_field() const {
  // @@protoc_insertion_point(field_get:MyProtoMessage.single_int64_field)
  return _internal_single_int64_field();
}
inline void MyProtoMessage::set_single_int64_field(::int64_t value) {
  _internal_set_single_int64_field(value);
  // @@protoc_insertion_point(field_set:MyProtoMessage.single_int64_field)
}
inline ::int64_t MyProtoMessage::_internal_single_int64_field() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.single_int64_field_;
}
inline void MyProtoMessage::_internal_set_single_int64_field(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.single_int64_field_ = value;
}

// repeated int32 repeated_int32_field = 3;
inline int MyProtoMessage::_internal_repeated_int32_field_size() const {
  return _internal_repeated_int32_field().size();
}
inline int MyProtoMessage::repeated_int32_field_size() const {
  return _internal_repeated_int32_field_size();
}
inline void MyProtoMessage::clear_repeated_int32_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repeated_int32_field_.Clear();
}
inline ::int32_t MyProtoMessage::repeated_int32_field(int index) const {
  // @@protoc_insertion_point(field_get:MyProtoMessage.repeated_int32_field)
  return _internal_repeated_int32_field().Get(index);
}
inline void MyProtoMessage::set_repeated_int32_field(int index, ::int32_t value) {
  _internal_mutable_repeated_int32_field()->Set(index, value);
  // @@protoc_insertion_point(field_set:MyProtoMessage.repeated_int32_field)
}
inline void MyProtoMessage::add_repeated_int32_field(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_repeated_int32_field()->Add(value);
  // @@protoc_insertion_point(field_add:MyProtoMessage.repeated_int32_field)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& MyProtoMessage::repeated_int32_field() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:MyProtoMessage.repeated_int32_field)
  return _internal_repeated_int32_field();
}
inline ::google::protobuf::RepeatedField<::int32_t>* MyProtoMessage::mutable_repeated_int32_field()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:MyProtoMessage.repeated_int32_field)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_repeated_int32_field();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
MyProtoMessage::_internal_repeated_int32_field() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repeated_int32_field_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* MyProtoMessage::_internal_mutable_repeated_int32_field() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.repeated_int32_field_;
}

// repeated int64 repeated_int64_field = 4;
inline int MyProtoMessage::_internal_repeated_int64_field_size() const {
  return _internal_repeated_int64_field().size();
}
inline int MyProtoMessage::repeated_int64_field_size() const {
  return _internal_repeated_int64_field_size();
}
inline void MyProtoMessage::clear_repeated_int64_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repeated_int64_field_.Clear();
}
inline ::int64_t MyProtoMessage::repeated_int64_field(int index) const {
  // @@protoc_insertion_point(field_get:MyProtoMessage.repeated_int64_field)
  return _internal_repeated_int64_field().Get(index);
}
inline void MyProtoMessage::set_repeated_int64_field(int index, ::int64_t value) {
  _internal_mutable_repeated_int64_field()->Set(index, value);
  // @@protoc_insertion_point(field_set:MyProtoMessage.repeated_int64_field)
}
inline void MyProtoMessage::add_repeated_int64_field(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_repeated_int64_field()->Add(value);
  // @@protoc_insertion_point(field_add:MyProtoMessage.repeated_int64_field)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& MyProtoMessage::repeated_int64_field() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:MyProtoMessage.repeated_int64_field)
  return _internal_repeated_int64_field();
}
inline ::google::protobuf::RepeatedField<::int64_t>* MyProtoMessage::mutable_repeated_int64_field()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:MyProtoMessage.repeated_int64_field)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_repeated_int64_field();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
MyProtoMessage::_internal_repeated_int64_field() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repeated_int64_field_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* MyProtoMessage::_internal_mutable_repeated_int64_field() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.repeated_int64_field_;
}

// .MyNestedMessage nested_message = 5;
inline bool MyProtoMessage::has_nested_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.nested_message_ != nullptr);
  return value;
}
inline void MyProtoMessage::clear_nested_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.nested_message_ != nullptr) _impl_.nested_message_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MyNestedMessage& MyProtoMessage::_internal_nested_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::MyNestedMessage* p = _impl_.nested_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::MyNestedMessage&>(::_MyNestedMessage_default_instance_);
}
inline const ::MyNestedMessage& MyProtoMessage::nested_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MyProtoMessage.nested_message)
  return _internal_nested_message();
}
inline void MyProtoMessage::unsafe_arena_set_allocated_nested_message(::MyNestedMessage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.nested_message_);
  }
  _impl_.nested_message_ = reinterpret_cast<::MyNestedMessage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MyProtoMessage.nested_message)
}
inline ::MyNestedMessage* MyProtoMessage::release_nested_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MyNestedMessage* released = _impl_.nested_message_;
  _impl_.nested_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::MyNestedMessage* MyProtoMessage::unsafe_arena_release_nested_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MyProtoMessage.nested_message)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MyNestedMessage* temp = _impl_.nested_message_;
  _impl_.nested_message_ = nullptr;
  return temp;
}
inline ::MyNestedMessage* MyProtoMessage::_internal_mutable_nested_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.nested_message_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::MyNestedMessage>(GetArena());
    _impl_.nested_message_ = reinterpret_cast<::MyNestedMessage*>(p);
  }
  return _impl_.nested_message_;
}
inline ::MyNestedMessage* MyProtoMessage::mutable_nested_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::MyNestedMessage* _msg = _internal_mutable_nested_message();
  // @@protoc_insertion_point(field_mutable:MyProtoMessage.nested_message)
  return _msg;
}
inline void MyProtoMessage::set_allocated_nested_message(::MyNestedMessage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.nested_message_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.nested_message_ = reinterpret_cast<::MyNestedMessage*>(value);
  // @@protoc_insertion_point(field_set_allocated:MyProtoMessage.nested_message)
}

// -------------------------------------------------------------------

// MyNestedMessage

// int32 nested_int32_field = 1;
inline void MyNestedMessage::clear_nested_int32_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nested_int32_field_ = 0;
}
inline ::int32_t MyNestedMessage::nested_int32_field() const {
  // @@protoc_insertion_point(field_get:MyNestedMessage.nested_int32_field)
  return _internal_nested_int32_field();
}
inline void MyNestedMessage::set_nested_int32_field(::int32_t value) {
  _internal_set_nested_int32_field(value);
  // @@protoc_insertion_point(field_set:MyNestedMessage.nested_int32_field)
}
inline ::int32_t MyNestedMessage::_internal_nested_int32_field() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nested_int32_field_;
}
inline void MyNestedMessage::_internal_set_nested_int32_field(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nested_int32_field_ = value;
}

// int64 nested_int64_field = 2;
inline void MyNestedMessage::clear_nested_int64_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nested_int64_field_ = ::int64_t{0};
}
inline ::int64_t MyNestedMessage::nested_int64_field() const {
  // @@protoc_insertion_point(field_get:MyNestedMessage.nested_int64_field)
  return _internal_nested_int64_field();
}
inline void MyNestedMessage::set_nested_int64_field(::int64_t value) {
  _internal_set_nested_int64_field(value);
  // @@protoc_insertion_point(field_set:MyNestedMessage.nested_int64_field)
}
inline ::int64_t MyNestedMessage::_internal_nested_int64_field() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nested_int64_field_;
}
inline void MyNestedMessage::_internal_set_nested_int64_field(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nested_int64_field_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_proto_2fcommon_2fcommon_5fmessage_2eproto_2epb_2eh
