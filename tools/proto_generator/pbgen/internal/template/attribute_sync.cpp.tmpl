// Code generated by pbgen. DO NOT EDIT.

#include "{{ .ProtoHeaderFile }}"
#include "{{ .MessageName | ToLower }}_attribute_sync.h"

// 引擎核心依赖
#include "engine/threading/registry_manager.h"
// 场景相关依赖
#include "scene/scene/comp/scene_node_scene.h"
// 网络相关依赖
#include "network/player_message_utils.h"

// ============================================================================
// 模板核心函数：处理不同类型玩家列表的属性同步
// 模板参数：PlayerContainer - 玩家列表容器类型（支持vector/unordered_set等）
// 功能：通用属性同步逻辑，适配任意可迭代的玩家容器类型
// ============================================================================
template <typename PlayerContainer>
void {{ .MessageName }}SyncAttributesCore(entt::entity entity, uint32_t message_id, const PlayerContainer& targetPlayers)
{
    // 1. 前置校验：空实体或空玩家列表直接返回
    if (entity == entt::null || targetPlayers.empty()) {
        return;
    }

    // 获取线程局部的Actor注册表（核心数据容器）
    auto& actorRegistry = tlsRegistryManager.actorRegistry;

    // 2. 获取脏掩码组件
    auto& dirtyMaskComp = actorRegistry.get_or_emplace<{{ .MessageName }}DirtyMaskComp>(entity);

    // 3. 初始化Proto消息对象
    {{ .CppClass }} syncMsg;
    const auto* msgDescriptor = syncMsg.GetDescriptor();
    // 防御性校验：消息描述符无效则返回（避免空指针）
    if (msgDescriptor == nullptr) {
        return;
    }

    // 4. 遍历所有字段，仅同步脏字段
    for (int fieldIdx = 0; fieldIdx < msgDescriptor->field_count(); ++fieldIdx)
    {
        // 获取当前字段描述符，跳过无效字段
        const auto* fieldDesc = msgDescriptor->field(fieldIdx);
        if (fieldDesc == nullptr) {
            continue;
        }

        // 获取字段编号（对应脏掩码的bit位索引）
        const int fieldNumber = fieldDesc->number();

        // 跳过未标记为脏的字段（非脏字段无需同步）
        if (!dirtyMaskComp.dirtyMask.test(fieldNumber)) {
            continue;
        }

        // 5. 根据字段编号匹配并同步属性
        switch (fieldNumber)
        {
        {{- if .Fields }}
        {{- range .Fields }}
        case {{ $.CppClass }}::k{{ .CamelFieldName }}FieldNumber:
        {
            // 同步 {{ .FieldName }} 属性（字段编号：{{ .Number }}）
            {{- if or (eq .FieldName "entity_id") (eq .FieldName "player_id") }}
            // 特殊处理：基础数值类型字段（uint64_t）直接赋值
            auto& fieldValue = actorRegistry.get_or_emplace<uint64_t>(entity);
            syncMsg.set_{{ .FieldName }}(fieldValue);
            dirtyMaskComp.dirtyMask.reset(fieldNumber);
            {{- else }}
            // 通用处理：消息类型字段通过CopyFrom同步
            auto& fieldComponent = actorRegistry.get_or_emplace<{{ .FieldType }}>(entity);
            if (syncMsg.mutable_{{ .FieldName }}() != nullptr) {
                syncMsg.mutable_{{ .FieldName }}()->CopyFrom(fieldComponent);
                // 同步完成后清除脏标记
                dirtyMaskComp.dirtyMask.reset(fieldNumber);
            }
            {{- end }}
            break;
        }
        {{- end }}
        {{- else }}
        // 无字段可同步（Proto消息为空）
        {{- end }}
        default:
            // 未知字段编号，跳过处理
            break;
        }
    }

    // 前置校验：消息无有效内容，无需广播
    if (syncMsg.ByteSizeLong() == 0) {
        return;
    }

    // 6. 广播消息到指定的玩家列表（模板适配任意可迭代容器）
    BroadcastMessageToPlayers(
        message_id,
        syncMsg,
        targetPlayers
    );

    // 显式清理消息对象（RAII自动处理，此处仅为语义说明）
    syncMsg.Clear();
}

// ============================================================================
// {{ .MessageName }} Attribute Sync (原始版本：使用AOI列表)
// 功能：同步 {{ .MessageName }} 消息对应的实体属性到AOI范围内的所有玩家
// 参数：
//   entity: entt 实体ID，标识需要同步属性的目标实体
//   message_id: 网络广播使用的消息ID，用于客户端识别消息类型
// 返回值：void
// ============================================================================
void {{ .MessageName }}SyncAttributes(entt::entity entity, uint32_t message_id)
{
    if (entity == entt::null) {
        return;
    }

    auto& actorRegistry = tlsRegistryManager.actorRegistry;
    const auto& aoiListComp = actorRegistry.get_or_emplace<AoiListComp>(entity);

    // 调用模板核心函数，传入AOI列表（自动推导容器类型）
    {{ .MessageName }}SyncAttributesCore(entity, message_id, aoiListComp.aoiList);
}

// ============================================================================
// {{ .MessageName }} Attribute Sync (重载版本：EntityUnorderedSet)
// 功能：同步 {{ .MessageName }} 消息对应的实体属性到指定的无序玩家集合
// 参数：
//   entity: entt 实体ID，标识需要同步属性的目标实体
//   message_id: 网络广播使用的消息ID，用于客户端识别消息类型
//   targetPlayers: 需要同步的玩家实体集合（无序）
// 返回值：void
// ============================================================================
void {{ .MessageName }}SyncAttributes(entt::entity entity, uint32_t message_id, const EntityUnorderedSet& targetPlayers)
{
    // 调用模板核心函数，传入无序集合
    {{ .MessageName }}SyncAttributesCore(entity, message_id, targetPlayers);
}

// ============================================================================
// {{ .MessageName }} Attribute Sync (重载版本：EntityVector)
// 功能：同步 {{ .MessageName }} 消息对应的实体属性到指定的有序玩家列表
// 参数：
//   entity: entt 实体ID，标识需要同步属性的目标实体
//   message_id: 网络广播使用的消息ID，用于客户端识别消息类型
//   targetPlayers: 需要同步的玩家实体列表（有序）
// 返回值：void
// ============================================================================
void {{ .MessageName }}SyncAttributes(entt::entity entity, uint32_t message_id, const EntityVector& targetPlayers)
{
    // 调用模板核心函数，传入有序列表
    {{ .MessageName }}SyncAttributesCore(entity, message_id, targetPlayers);
}

// ============================================================================
// Set{{ .MessageName }}AttrDirtyBit
// 功能：设置 {{ .MessageName }} 消息对应属性的脏位（自动扩容bitset）
// 参数：
//   entity: entt 实体ID，标识需要操作的目标实体
//   bitIdx: 脏位索引，对应Proto消息中字段的编号
// 返回值：void
// ============================================================================
void Set{{ .MessageName }}AttrDirtyBit(entt::entity entity, std::size_t bitIdx)
{
    // 获取线程局部的Actor注册表
    auto& actorRegistry = tlsRegistryManager.actorRegistry;

    // 获取/创建脏掩码组件
    auto& dirtyMaskComp = actorRegistry.get_or_emplace<{{ .MessageName }}DirtyMaskComp>(entity);

    // 自动扩容bitset：确保脏位索引有效
    if (dirtyMaskComp.dirtyMask.size() <= bitIdx) {
        dirtyMaskComp.dirtyMask.resize(bitIdx + 1);
    }

    // 标记该位为脏（需要同步）
    dirtyMaskComp.dirtyMask.set(bitIdx);
}