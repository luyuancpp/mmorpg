#include "{{ .ProtoHeaderFile }}"
#include "{{ .MessageName | ToLower }}_attribute_sync.h"

#include "engine/threading/registry_manager.h"
#include "scene/scene/comp/scene_node_scene.h"
#include "network/player_message_utils.h"

namespace scene {
namespace attribute_sync {

// ============================================================================
// {{ .MessageName }} Attribute Sync
// 功能：同步 {{ .MessageName }} 消息对应的实体属性到AOI范围内的玩家
// 参数：
//   entity: entt 实体ID
//   message_id: 广播使用的消息ID
// 返回值：void
// ============================================================================
void {{ .MessageName }}SyncAttributes(entt::entity entity, uint32_t message_id)
{
    // 空实体校验
    if (entity == entt::null) {
        return;
    }

    auto& registry = tlsRegistryManager.actorRegistry;

    // 获取/创建AOI列表组件和脏掩码组件
    const auto& aoi_list      = registry.get_or_emplace<AoiListComp>(entity);
    auto&       dirty_mask    = registry.get_or_emplace<{{ .MessageName }}DirtyMaskComp>(entity);

    // 空AOI列表直接返回，无需广播
    if (aoi_list.aoiList.empty()) {
        return;
    }

    // 创建同步用的Proto消息对象
    {{ .CppClass }} sync_msg;
    const auto* msg_desc = sync_msg.GetDescriptor();
    if (msg_desc == nullptr) { // 防御性校验：确保消息描述符有效
        return;
    }

    // 遍历Proto消息的所有字段，仅同步脏字段
    for (int idx = 0; idx < msg_desc->field_count(); ++idx)
    {
        const auto* field     = msg_desc->field(idx);
        if (field == nullptr) { // 跳过无效字段
            continue;
        }
        
        int         field_num = field->number();

        // 跳过未标记为脏的字段
        if (!dirty_mask.dirtyMask.test(field_num))
            continue;

        // 根据字段编号匹配并同步对应属性
        switch (field_num)
        {
        {{- if .Fields }}
        {{- range .Fields }}
        case {{ $.CppClass }}::k{{ .CamelFieldName }}FieldNumber:
        {
            // 同步 {{ .FieldName }} 属性（字段编号：{{ .Number }}）
            {{- if eq .FieldName "entity_id" }}
            // 特殊处理：entity_id字段固定为uint64_t类型
            auto& comp = registry.get_or_emplace<uint64_t>(entity);
            sync_msg.set_entity_id(comp);
            dirty_mask.dirtyMask.reset(field_num);
            {{- else }}
            auto& comp = registry.get_or_emplace<{{ .FieldType }}>(entity);
            if (sync_msg.mutable_{{ .FieldName }}() != nullptr) {
                sync_msg.mutable_{{ .FieldName }}()->CopyFrom(comp);
                // 同步后清除该字段的脏标记
                dirty_mask.dirtyMask.reset(field_num);
            }
            {{- end }}
            break;
        }
        {{- end }}
        {{- else }}
        // 无字段可同步
        {{- end }}
        default:
            // 未知字段编号，跳过
            break;
        }
    }

    // 消息无内容时，无需广播
    if (sync_msg.ByteSizeLong() == 0)
        return;

    // 广播同步消息到AOI范围内的所有玩家
    BroadcastMessageToPlayers(
        message_id,
        sync_msg,
        aoi_list.aoiList
    );

    // 清理消息对象（可选，RAII会自动处理，此处为显式说明）
    sync_msg.Clear();
}

} // namespace attribute_sync
} // namespace scene