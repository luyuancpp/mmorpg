// Code generated by pbgen. DO NOT EDIT.

#include "proto/service/cpp/rpc/scene/player_state_attribute_sync.pb.h"
#include "attributedelta5framess2c_attribute_sync.h"

// 引擎核心依赖
#include "engine/threading/registry_manager.h"
// 场景相关依赖
#include "scene/scene/comp/scene_node_scene.h"
// 网络相关依赖
#include "network/player_message_utils.h"

// ============================================================================
// AttributeDelta5FramesS2C Attribute Sync
// 功能：同步 AttributeDelta5FramesS2C 消息对应的实体属性到AOI范围内的所有玩家
// 参数：
//   entity: entt 实体ID，标识需要同步属性的目标实体
//   message_id: 网络广播使用的消息ID，用于客户端识别消息类型
// 返回值：void
// 注意：仅同步标记为"脏"的字段，空消息/空AOI列表会直接返回
// ============================================================================
void AttributeDelta5FramesS2CSyncAttributes(entt::entity entity, uint32_t message_id)
{
    // 1. 前置校验：空实体直接返回
    if (entity == entt::null) {
        return;
    }

    // 获取线程局部的Actor注册表（核心数据容器）
    auto& actorRegistry = tlsRegistryManager.actorRegistry;

    // 2. 获取/创建核心组件
    // AOI列表组件：存储需要同步的玩家列表
    const auto& aoiListComp = actorRegistry.get_or_emplace<AoiListComp>(entity);
    // 脏掩码组件：标记哪些字段需要同步
    auto& dirtyMaskComp = actorRegistry.get_or_emplace<AttributeDelta5FramesS2CDirtyMaskComp>(entity);

    // 前置校验：AOI列表为空，无需广播
    if (aoiListComp.aoiList.empty()) {
        return;
    }

    // 3. 初始化Proto消息对象
    AttributeDelta5FramesS2C syncMsg;
    const auto* msgDescriptor = syncMsg.GetDescriptor();
    // 防御性校验：消息描述符无效则返回（避免空指针）
    if (msgDescriptor == nullptr) {
        return;
    }

    // 4. 遍历所有字段，仅同步脏字段
    for (int fieldIdx = 0; fieldIdx < msgDescriptor->field_count(); ++fieldIdx)
    {
        // 获取当前字段描述符，跳过无效字段
        const auto* fieldDesc = msgDescriptor->field(fieldIdx);
        if (fieldDesc == nullptr) {
            continue;
        }

        // 获取字段编号（对应脏掩码的bit位索引）
        const int fieldNumber = fieldDesc->number();

        // 跳过未标记为脏的字段（非脏字段无需同步）
        if (!dirtyMaskComp.dirtyMask.test(fieldNumber)) {
            continue;
        }

        // 5. 根据字段编号匹配并同步属性
        switch (fieldNumber)
        {
        case AttributeDelta5FramesS2C::kEntityIdFieldNumber:
        {
            // 同步 entity_id 属性（字段编号：1）
            // 特殊处理：基础数值类型字段（uint64_t）直接赋值
            auto& fieldValue = actorRegistry.get_or_emplace<uint64_t>(entity);
            syncMsg.set_entity_id(fieldValue);
            dirtyMaskComp.dirtyMask.reset(fieldNumber);
            break;
        }
        default:
            // 未知字段编号，跳过处理
            break;
        }
    }

    // 前置校验：消息无有效内容，无需广播
    if (syncMsg.ByteSizeLong() == 0) {
        return;
    }

    // 6. 广播消息到AOI范围内的所有玩家
    BroadcastMessageToPlayers(
        message_id,
        syncMsg,
        aoiListComp.aoiList
    );

    // 显式清理消息对象（RAII自动处理，此处仅为语义说明）
    syncMsg.Clear();
}

// ============================================================================
// SetAttributeDelta5FramesS2CAttrDirtyBit
// 功能：设置 AttributeDelta5FramesS2C 消息对应属性的脏位（自动扩容bitset）
// 参数：
//   entity: entt 实体ID，标识需要操作的目标实体
//   bitIdx: 脏位索引，对应Proto消息中字段的编号
// 返回值：void
// 注意：如果脏位索引超出当前bitset长度，会自动扩容以容纳新索引
// ============================================================================
void SetAttributeDelta5FramesS2CAttrDirtyBit(entt::entity entity, std::size_t bitIdx)
{
    // 获取线程局部的Actor注册表
    auto& actorRegistry = tlsRegistryManager.actorRegistry;

    // 获取/创建脏掩码组件
    auto& dirtyMaskComp = actorRegistry.get_or_emplace<AttributeDelta5FramesS2CDirtyMaskComp>(entity);

    // 自动扩容bitset：确保脏位索引有效
    if (dirtyMaskComp.dirtyMask.size() <= bitIdx) {
        dirtyMaskComp.dirtyMask.resize(bitIdx + 1);
    }

    // 标记该位为脏（需要同步）
    dirtyMaskComp.dirtyMask.set(bitIdx);
}